<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Planar Triangulated Graph Visualizer</title>

    <!-- Required Libraries in Specified Order -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #f5f5f5;
        }

        .header {
            background: linear-gradient(to right, #3a6ea5, #6c8ebf);
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            margin: 0;
            font-size: 1.5rem;
        }

        .toolbar {
            background-color: #fff;
            padding: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            border-bottom: 1px solid #ddd;
        }

        .btn-group {
            display: flex;
            gap: 4px;
            align-items: center;
            border-right: 1px solid #eee;
            padding-right: 8px;
            margin-right: 4px;
        }

        .btn-group:last-child {
            border-right: none;
        }

        button {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            color: #333;
            transition: all 0.2s;
        }

        button:hover {
            background-color: #e9ecef;
        }

        button:active {
            background-color: #dee2e6;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background-color: #3a6ea5;
            color: white;
            border-color: #2a5e95;
        }

        button.primary:hover {
            background-color: #2a5e95;
        }

        button.active {
            background-color: #4a7eb5;
            color: white;
            border-color: #3a6ea5;
            box-shadow: 0 0 0 2px rgba(58, 110, 165, 0.3);
        }

        .btn-icon {
            font-weight: bold;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #f9f9f9;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .mouse-guide {
            position: absolute;
            left: 15px;
            bottom: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .mouse-guide ul {
            margin: 5px 0 0 20px;
            padding: 0;
        }

        .mouse-guide li {
            margin-bottom: 3px;
        }

        .side-panel {
            width: 300px;
            background-color: white;
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s;
        }

        .side-panel.collapsed {
            transform: translateX(100%);
        }

        .panel-header {
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            padding: 15px;
            overflow-y: auto;
            flex: 1;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #555;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .vertex-list {
            border: 1px solid #eee;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }

        .vertex-item {
            padding: 5px 10px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }

        .vertex-item:last-child {
            border-bottom: none;
        }

        .toggle-panel-btn {
            position: absolute;
            top: 50%;
            right: 300px;
            transform: translateY(-50%);
            width: 20px;
            height: 60px;
            background-color: white;
            border: 1px solid #ddd;
            border-right: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px 0 0 4px;
            z-index: 10;
            transition: right 0.3s;
        }

        .toggle-panel-btn.collapsed {
            right: 0;
        }

        .status-bar {
            height: 30px;
            background-color: #f8f9fa;
            border-top: 1px solid #ddd;
            padding: 0 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
            color: #555;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background-color: white;
            border-radius: 4px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
        }

        .modal-body {
            padding: 15px;
        }

        .modal-footer {
            padding: 15px;
            border-top: 1px solid #ddd;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }

        .form-control {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-control:focus {
            outline: none;
            border-color: #3a6ea5;
        }

        /* Custom Color Swatch UI */
        .color-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            align-items: center;
            margin-bottom: 10px;
        }

        .color-swatch {
            width: 80px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #ddd;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .color-swatch:hover {
            transform: scale(1.05);
            border-color: #3a6ea5;
        }

        /* Debug panel */
        .debug-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-height: 400px;
            background-color: white;
            color: #333;
            padding: 0;
            font-family: var(--font-main);
            font-size: 14px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }

        .debug-panel.show {
            display: block;
        }

        .debug-header {
            background-color: #3a6ea5;
            color: white;
            padding: 12px 15px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-close {
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }

        .debug-content {
            padding: 15px;
            overflow-y: auto;
            max-height: 340px;
        }

        .validation-result {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .validation-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .validation-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .validation-list {
            list-style-type: none;
            margin: 10px 0;
            padding: 0;
        }

        .validation-item {
            padding: 8px 10px;
            margin-bottom: 5px;
            background-color: #f8f9fa;
            border-left: 3px solid #dc3545;
            font-size: 13px;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Professional Planar Triangulated Graph Visualizer</h1>
        <div id="vertex-counter">Vertices: 0</div>
    </div>

    <div class="toolbar">
        <div class="btn-group">
            <button id="startBtn" class="primary">
                <span class="btn-icon">S</span>
                <span>Start</span>
            </button>
        </div>

        <div class="btn-group">
            <button id="addBtn" disabled>
                <span class="btn-icon">A</span>
                <span>Add Vertex</span>
            </button>
            <button id="randomBtn" disabled>
                <span class="btn-icon">R</span>
                <span>Random</span>
            </button>
        </div>

        <div class="btn-group">
            <button id="goToBtn" disabled>
                <span class="btn-icon">G</span>
                <span>Go To</span>
            </button>
        </div>

        <div class="btn-group">
            <button id="zoomInBtn" disabled>
                <span class="btn-icon">Z+</span>
            </button>
            <button id="zoomOutBtn" disabled>
                <span class="btn-icon">Z-</span>
            </button>
            <button id="centerBtn" disabled>
                <span class="btn-icon">C</span>
            </button>
        </div>

        <div class="btn-group">
            <button id="toggleBtn" disabled>
                <span class="btn-icon">T</span>
                <span>Toggle</span>
            </button>
            <button id="redrawBtn" disabled>
                <span>Redraw</span>
            </button>
            <button id="colorBtn" disabled>
                <span>Colors</span>
            </button>
        </div>

        <div class="btn-group">
            <button id="debugBtn">Debug</button>
            <button id="curveToggleBtn" disabled>
                <span>Curves</span>
            </button>
        </div>
    </div>

    <div class="main-container">
        <div class="canvas-container" id="canvas-container"></div>

        <div class="mouse-guide">
            <strong>Controls:</strong>
            <ul>
                <li>S: Start triangle</li>
                <li>A: Add vertex</li>
                <li>R: Random vertex</li>
                <li>T: Toggle display</li>
                <li>F: Fix graph issues</li>
                <li>Drag: Pan</li>
                <li>Wheel: Zoom</li>
            </ul>
        </div>

        <div class="toggle-panel-btn" id="togglePanelBtn">◀</div>

        <div class="side-panel" id="sidePanel">
            <div class="panel-header">
                <span>Graph Information</span>
            </div>
            <div class="panel-content">
                <div class="section">
                    <div class="section-title">Statistics</div>
                    <div class="stat-item">
                        <span>Vertices:</span>
                        <span id="vertexCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Edges:</span>
                        <span id="edgeCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Faces:</span>
                        <span id="faceCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Periphery:</span>
                        <span id="peripheryCount">0</span>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Selection</div>
                    <div id="selectionInfo">None</div>
                </div>

                <div class="section">
                    <div class="section-title">Periphery Vertices</div>
                    <div class="vertex-list" id="peripheryList">
                        <div class="vertex-item">No vertices yet</div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Display Settings</div>
                    <div class="stat-item">
                        <span>Mode:</span>
                        <span id="displayMode">Index</span>
                    </div>
                    <div class="stat-item">
                        <span>Visible up to:</span>
                        <span id="visibleUpTo">All</span>
                    </div>
                    <div class="stat-item">
                        <span>Curved edges:</span>
                        <span id="curvedStatus">Off</span>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Actions</div>
                    <div style="display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap;">
                        <button id="validateBtn">Validate</button>
                        <button id="fixBtn">Fix Graph</button>
                        <button id="exportBtn">Export</button>
                        <button id="importBtn">Import</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div id="statusText">Ready to start. Press 'S' to create initial triangle.</div>
        <div id="coordinates"></div>
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debugPanel">
        <div class="debug-header">
            <span>Validation Results</span>
            <span class="debug-close" id="closeDebugBtn">×</span>
        </div>
        <div class="debug-content" id="debugContent"></div>
    </div>

    <!-- Go To Modal -->
    <div class="modal" id="goToModal">
        <div class="modal-content">
            <div class="modal-header">Go To Vertex (Gm Command)</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="vertexIndex">Enter vertex number m:</label>
                    <input type="number" id="vertexIndex" class="form-control" min="1">
                    <small>Shows vertices 1 through m only</small>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelGoToBtn">Cancel</button>
                <button id="confirmGoToBtn" class="primary">Go</button>
            </div>
        </div>
    </div>

    <!-- Color Modal -->
    <div class="modal" id="colorModal">
        <div class="modal-content">
            <div class="modal-header">Color Settings</div>
            <div class="modal-body">
                <div class="color-row">
                    <label>Vertex Color 1:</label>
                    <div class="color-swatch" id="swatch-color1"></div>
                </div>
                <div class="color-row">
                    <label>Vertex Color 2:</label>
                    <div class="color-swatch" id="swatch-color2"></div>
                </div>
                <div class="color-row">
                    <label>Vertex Color 3:</label>
                    <div class="color-swatch" id="swatch-color3"></div>
                </div>
                <div class="color-row">
                    <label>Vertex Color 4:</label>
                    <div class="color-swatch" id="swatch-color4"></div>
                </div>
                <div class="color-row">
                    <label>Border Color:</label>
                    <div class="color-swatch" id="swatch-borderColor"></div>
                </div>
                <div class="color-row">
                    <label>Edge Color:</label>
                    <div class="color-swatch" id="swatch-edgeColor"></div>
                </div>
                <div class="color-row">
                    <label>Periphery Color:</label>
                    <div class="color-swatch" id="swatch-peripheryColor"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="resetColorsBtn">Reset</button>
                <button id="saveColorsBtn" class="primary">Apply</button>
            </div>
        </div>
    </div>

    <script>
        (function () {
            // ===================================================================
            // CONFIGURATION & CONSTANTS - UPDATED WITH BETTER VALUES
            // ===================================================================

            const CONFIG = {
                VERTEX_BASE_RADIUS: 20,
                MIN_VERTEX_RADIUS: 15,
                MAX_VERTEX_RADIUS: 40,
                INITIAL_TRIANGLE_SIZE: 250,
                ZOOM_FACTOR: 1.1,
                MAX_VERTICES: 10000,
                MIN_ANGLE_THRESHOLD: Math.PI / 4, // Improved from PI/3 to PI/4 for better angular resolution
                MIN_EDGE_LENGTH: 60,
                MAX_EDGE_LENGTH: 300,
                MIN_VERTEX_DISTANCE: 80, // Increased from 50 for better spacing
                CURVE_FACTOR: 0.15,
                REDRAW_ANGLE_THRESHOLD: Math.PI / 3,
                EDGE_LENGTH_TOLERANCE: 0.2,
                CONVEX_HULL_EPSILON: 1e-9,
                OVERLAP_SAFETY_MARGIN: 25, // Increased from 20
                MIN_SELECTION_ANGLE: Math.PI / 6,
                VERTEX_EDGE_SAFETY_MARGIN: 15,

                // Smart placement configuration - IMPROVED WEIGHTS
                CANDIDATE_POSITIONS: 24,
                SEARCH_RADIUS_MIN: 80,
                SEARCH_RADIUS_MAX: 400,
                SEARCH_RADIUS_STEPS: 8,
                LOCAL_RELAXATION_ITERATIONS: 15,
                GLOBAL_RELAXATION_ITERATIONS: 5,
                RELAXATION_TEMPERATURE: 0.3,
                POSITION_QUALITY_WEIGHTS: {
                    overlap: 2000,           // Doubled from 1000
                    minDistance: 1000,       // Doubled from 500
                    angleQuality: 1500,      // 5x increase from 300
                    edgeLengthVariance: 200,
                    peripheryDistance: 100,
                    vertexEdgeDistance: 400,
                    curveOverlap: 450
                },

                // Matter.js Physics Configuration
                PHYSICS_ITERATIONS: 500,
                PHYSICS_TIME_LIMIT: 5000,
                COLLISION_MARGIN: 25,
                PHYSICS_RESTITUTION: 0.7,
                PHYSICS_FRICTION: 0.1,
                PHYSICS_STIFFNESS: 0.4,
                PHYSICS_DAMPING: 0.1,
                REPULSION_STRENGTH: 0.002
            };

            // ===================================================================
            // GLOBAL VARIABLES
            // ===================================================================

            let stage, faceLayer, edgeLayer, vertexLayer;
            let konvaShapes = { vertices: {}, edges: {}, faces: {} };

            let graph = {
                vertices: [],
                edges: [],
                faces: [],
                periphery: [],
                adjacencyMatrix: null,
                edgeLengths: new Map()
            };

            let view = {
                showIndex: true,
                showCurvedEdges: false,
                maxVisibleVertex: Number.MAX_SAFE_INTEGER,
                performanceWarningShown: false
            };

            // Colors using natural numbers 1-4 as specified in PDF
            let colors = {
                vertexColors: ['#b8cfe5', '#ffadad', '#ffd6a5', '#caffbf'], // Colors 1-4
                vertexBorderColor: '#333333',
                edgeColor: '#555555',
                peripheryColor: '#e63946',
                selectedColor: '#f9c74f',
                textColor: '#333333'
            };

            const defaultColors = JSON.parse(JSON.stringify(colors));

            let selection = {
                mode: 'none',
                vertices: [],
                firstVertex: null,
                secondVertex: null
            };

            // QuadTree for spatial indexing
            class QuadTree {
                constructor(boundary, capacity = 4) {
                    this.boundary = boundary; // {x, y, width, height}
                    this.capacity = capacity;
                    this.vertices = [];
                    this.divided = false;
                    this.northeast = null;
                    this.northwest = null;
                    this.southeast = null;
                    this.southwest = null;
                }

                contains(point) {
                    return point.x >= this.boundary.x &&
                        point.x <= this.boundary.x + this.boundary.width &&
                        point.y >= this.boundary.y &&
                        point.y <= this.boundary.y + this.boundary.height;
                }

                intersects(range) {
                    return !(range.x > this.boundary.x + this.boundary.width ||
                        range.x + range.width < this.boundary.x ||
                        range.y > this.boundary.y + this.boundary.height ||
                        range.y + range.height < this.boundary.y);
                }

                subdivide() {
                    const x = this.boundary.x;
                    const y = this.boundary.y;
                    const w = this.boundary.width / 2;
                    const h = this.boundary.height / 2;

                    this.northeast = new QuadTree({ x: x + w, y: y, width: w, height: h }, this.capacity);
                    this.northwest = new QuadTree({ x: x, y: y, width: w, height: h }, this.capacity);
                    this.southeast = new QuadTree({ x: x + w, y: y + h, width: w, height: h }, this.capacity);
                    this.southwest = new QuadTree({ x: x, y: y + h, width: w, height: h }, this.capacity);
                    this.divided = true;
                }

                insert(vertex) {
                    if (!this.contains(vertex)) return false;

                    if (this.vertices.length < this.capacity) {
                        this.vertices.push(vertex);
                        return true;
                    }

                    if (!this.divided) {
                        this.subdivide();
                    }

                    return this.northeast.insert(vertex) ||
                        this.northwest.insert(vertex) ||
                        this.southeast.insert(vertex) ||
                        this.southwest.insert(vertex);
                }

                query(range, found = []) {
                    if (!this.intersects(range)) return found;

                    for (const v of this.vertices) {
                        if (this.contains(v)) {
                            found.push(v);
                        }
                    }

                    if (this.divided) {
                        this.northeast.query(range, found);
                        this.northwest.query(range, found);
                        this.southeast.query(range, found);
                        this.southwest.query(range, found);
                    }

                    return found;
                }
            }

            let quadTree = null;
            let physicsEngine = null;
            let physicsRunner = null;

            // ===================================================================
            // DOM ELEMENTS
            // ===================================================================

            const startBtn = document.getElementById('startBtn');
            const addBtn = document.getElementById('addBtn');
            const randomBtn = document.getElementById('randomBtn');
            const goToBtn = document.getElementById('goToBtn');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const centerBtn = document.getElementById('centerBtn');
            const toggleBtn = document.getElementById('toggleBtn');
            const redrawBtn = document.getElementById('redrawBtn');
            const colorBtn = document.getElementById('colorBtn');
            const debugBtn = document.getElementById('debugBtn');
            const validateBtn = document.getElementById('validateBtn');
            const fixBtn = document.getElementById('fixBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const curveToggleBtn = document.getElementById('curveToggleBtn');

            const togglePanelBtn = document.getElementById('togglePanelBtn');
            const sidePanel = document.getElementById('sidePanel');
            const statusText = document.getElementById('statusText');
            const coordinates = document.getElementById('coordinates');
            const vertexCounter = document.getElementById('vertex-counter');
            const vertexCount = document.getElementById('vertexCount');
            const edgeCount = document.getElementById('edgeCount');
            const faceCount = document.getElementById('faceCount');
            const peripheryCount = document.getElementById('peripheryCount');
            const peripheryList = document.getElementById('peripheryList');
            const selectionInfo = document.getElementById('selectionInfo');
            const displayMode = document.getElementById('displayMode');
            const visibleUpTo = document.getElementById('visibleUpTo');
            const curvedStatus = document.getElementById('curvedStatus');
            const debugPanel = document.getElementById('debugPanel');

            // Modal Elements
            const goToModal = document.getElementById('goToModal');
            const vertexIndex = document.getElementById('vertexIndex');
            const confirmGoToBtn = document.getElementById('confirmGoToBtn');
            const cancelGoToBtn = document.getElementById('cancelGoToBtn');

            const colorModal = document.getElementById('colorModal');
            const resetColorsBtn = document.getElementById('resetColorsBtn');
            const saveColorsBtn = document.getElementById('saveColorsBtn');

            // ===================================================================
            // UTILITY FUNCTIONS
            // ===================================================================

            function log(message, data = null) {
                console.log(`[${new Date().toLocaleTimeString()}] ${message}`, data || '');
            }

            function showAlert(message, type = 'info') {
                const iconMap = {
                    'success': 'success',
                    'error': 'error',
                    'warning': 'warning',
                    'info': 'info'
                };

                Swal.fire({
                    title: message,
                    icon: iconMap[type] || 'info',
                    toast: true,
                    position: 'top-end',
                    showConfirmButton: false,
                    timer: 3000,
                    timerProgressBar: true,
                    showClass: { popup: 'swal2-noanimation' },
                    hideClass: { popup: '' }
                });
            }

         
            function showLoading(show, message = 'Processing...', isUpdate = false) {
                if (show) {
                    if (Swal.isVisible() && isUpdate) {
                      
                        Swal.update({
                            title: message
                        });
                    } else if (!Swal.isVisible()) {
                       
                        Swal.fire({
                            title: message,
                            allowOutsideClick: false,
                            allowEscapeKey: false,
                            showConfirmButton: false,
                            didOpen: () => {
                                Swal.showLoading();
                            }
                        });
                    }
                } else {
                   
                    Swal.close();
                }
            }

            function updateStatus(message) {
                statusText.textContent = message;
            }

            function getVertexRadius(vertexId) {
                const digitCount = (vertexId + 1).toString().length;
                return Math.min(
                    CONFIG.VERTEX_BASE_RADIUS + (digitCount - 1) * 6,
                    CONFIG.MAX_VERTEX_RADIUS
                );
            }

            // ===================================================================
            // KONVA RENDERING SYSTEM - FIXED WITH PROPER UPDATE SYSTEM
            // ===================================================================

            function initKonva() {
                const container = document.getElementById('canvas-container');

                stage = new Konva.Stage({
                    container: container,
                    width: container.clientWidth,
                    height: container.clientHeight,
                    draggable: true
                });

                // Create layers in correct z-order
                faceLayer = new Konva.Layer();
                edgeLayer = new Konva.Layer();
                vertexLayer = new Konva.Layer();

                stage.add(faceLayer);
                stage.add(edgeLayer);
                stage.add(vertexLayer);

                // Setup zoom
                stage.on('wheel', (e) => {
                    e.evt.preventDefault();

                    const oldScale = stage.scaleX();
                    const pointer = stage.getPointerPosition();

                    const mousePointTo = {
                        x: (pointer.x - stage.x()) / oldScale,
                        y: (pointer.y - stage.y()) / oldScale
                    };

                    const direction = e.evt.deltaY > 0 ? -1 : 1;
                    const factor = direction > 0 ? CONFIG.ZOOM_FACTOR : 1 / CONFIG.ZOOM_FACTOR;
                    const newScale = Math.max(0.1, Math.min(10, oldScale * factor));

                    stage.scale({ x: newScale, y: newScale });

                    const newPos = {
                        x: pointer.x - mousePointTo.x * newScale,
                        y: pointer.y - mousePointTo.y * newScale
                    };

                    stage.position(newPos);
                    stage.batchDraw();
                });

                // Update coordinates on mouse move
                stage.on('mousemove', (e) => {
                    const pos = stage.getPointerPosition();
                    const transform = stage.getAbsoluteTransform().copy();
                    transform.invert();
                    const graphPos = transform.point(pos);
                    coordinates.textContent = `(${Math.round(graphPos.x)}, ${Math.round(graphPos.y)})`;
                });

                log('Konva initialized successfully');
            }

            // OPTIMIZED VERTEX POSITION UPDATE - NO RECREATION
            function updateVertexPositions() {
                // Update vertex positions without recreating shapes
                for (const vertex of graph.vertices) {
                    if (vertex.id > view.maxVisibleVertex) continue;

                    const shape = konvaShapes.vertices[vertex.id];
                    if (shape) {
                        // Just update position - much faster than recreation
                        shape.position({ x: vertex.x, y: vertex.y });
                    }
                }

                // Batch update edges using requestAnimationFrame for smooth animation
                requestAnimationFrame(() => {
                    for (const edge of graph.edges) {
                        if (edge.v1 > view.maxVisibleVertex || edge.v2 > view.maxVisibleVertex) continue;

                        const edgeKey = `${edge.v1}-${edge.v2}`;
                        const shape = konvaShapes.edges[edgeKey];

                        if (shape) {
                            const v1 = graph.vertices[edge.v1];
                            const v2 = graph.vertices[edge.v2];

                            if (shape instanceof Konva.Path && view.showCurvedEdges) {
                                // Update path data for curved edges
                                const control = calculateCurveControlPoint(v1, v2);
                                const pathData = `M ${v1.x},${v1.y} Q ${control.x},${control.y} ${v2.x},${v2.y}`;
                                shape.data(pathData);
                            } else if (shape instanceof Konva.Line) {
                                // Update points for straight edges
                                shape.points([v1.x, v1.y, v2.x, v2.y]);
                            }
                        }
                    }

                    // Update face positions
                    for (let i = 0; i < graph.faces.length; i++) {
                        const face = graph.faces[i];
                        if (face.length === 3 && konvaShapes.faces[i]) {
                            const points = [];
                            for (const vertexId of face) {
                                const vertex = graph.vertices[vertexId];
                                points.push(vertex.x, vertex.y);
                            }
                            konvaShapes.faces[i].points(points);
                        }
                    }

                    // Single batch draw for all updates
                    stage.batchDraw();
                });
            }

            function drawVertices() {
                const processedIds = new Set();

                for (const vertex of graph.vertices) {
                    if (vertex.id > view.maxVisibleVertex) continue;

                    processedIds.add(vertex.id);

                    const isSelected = selection.vertices.includes(vertex.id);
                    const isPeriphery = graph.periphery.includes(vertex.id);
                    const radius = getVertexRadius(vertex.id);

                    let fillColor;
                    if (isSelected) {
                        fillColor = colors.selectedColor;
                    } else if (view.showIndex) {
                        fillColor = colors.vertexColors[0];
                    } else {
                        fillColor = colors.vertexColors[(vertex.color - 1) % colors.vertexColors.length];
                    }

                    if (konvaShapes.vertices[vertex.id]) {
                        // UPDATE EXISTING VERTEX
                        const group = konvaShapes.vertices[vertex.id];
                        group.position({ x: vertex.x, y: vertex.y });

                        const circle = group.findOne('Circle');
                        if (circle) {
                            circle.radius(radius);
                            circle.fill(fillColor);
                            circle.stroke(isPeriphery ? colors.peripheryColor : colors.vertexBorderColor);
                            circle.strokeWidth(isPeriphery ? 3 : 2);
                        }

                        const text = group.findOne('Text');
                        if (text) {
                            const label = view.showIndex ? (vertex.id + 1).toString() : vertex.color.toString();
                            const fontSize = Math.max(10, Math.min(18, radius * 0.65));
                            text.text(label);
                            text.fontSize(fontSize);
                            text.offsetY(fontSize / 2);
                            text.offsetX(text.width() / 2);
                        }

                        const highlight = group.findOne('.highlight');
                        if (isSelected && !highlight) {
                            const newHighlight = new Konva.Circle({
                                radius: radius + 8,
                                stroke: colors.selectedColor,
                                strokeWidth: 3,
                                dash: [5, 5],
                                name: 'highlight'
                            });
                            group.add(newHighlight);
                        } else if (!isSelected && highlight) {
                            highlight.destroy();
                        } else if (isSelected && highlight) {
                            highlight.radius(radius + 8);
                        }

                    } else {
                        // CREATE NEW VERTEX
                        const group = new Konva.Group({
                            x: vertex.x,
                            y: vertex.y
                        });

                        const circle = new Konva.Circle({
                            radius: radius,
                            fill: fillColor,
                            stroke: isPeriphery ? colors.peripheryColor : colors.vertexBorderColor,
                            strokeWidth: isPeriphery ? 3 : 2,
                            shadowColor: 'rgba(0, 0, 0, 0.25)',
                            shadowBlur: 6,
                            shadowOffsetX: 3,
                            shadowOffsetY: 3
                        });

                        const label = view.showIndex ? (vertex.id + 1).toString() : vertex.color.toString();
                        const fontSize = Math.max(10, Math.min(18, radius * 0.65));
                        const text = new Konva.Text({
                            text: label,
                            fontSize: fontSize,
                            fontFamily: 'Arial',
                            fontStyle: 'bold',
                            fill: colors.textColor,
                            align: 'center',
                            verticalAlign: 'middle',
                            offsetX: 0,
                            offsetY: fontSize / 2
                        });

                        text.offsetX(text.width() / 2);

                        group.add(circle);
                        group.add(text);

                        if (isSelected) {
                            const highlight = new Konva.Circle({
                                radius: radius + 8,
                                stroke: colors.selectedColor,
                                strokeWidth: 3,
                                dash: [5, 5],
                                name: 'highlight'
                            });
                            group.add(highlight);
                        }

                        group.on('mousedown', () => {
                            handleVertexClick(vertex.id);
                        });

                        group.on('mouseenter', () => {
                            document.body.style.cursor = 'pointer';
                        });

                        group.on('mouseleave', () => {
                            document.body.style.cursor = 'default';
                        });

                        vertexLayer.add(group);
                        konvaShapes.vertices[vertex.id] = group;
                    }
                }

                // Remove shapes for vertices that no longer exist or are not visible
                for (const id in konvaShapes.vertices) {
                    if (!processedIds.has(parseInt(id))) {
                        konvaShapes.vertices[id].destroy();
                        delete konvaShapes.vertices[id];
                    }
                }

                vertexLayer.batchDraw();
            }

            // FIXED CURVED EDGE RENDERING WITH KONVA.PATH
            function drawEdges() {
                const processedEdges = new Set();

                for (let i = 0; i < graph.edges.length; i++) {
                    const edge = graph.edges[i];

                    if (edge.v1 > view.maxVisibleVertex || edge.v2 > view.maxVisibleVertex) {
                        continue;
                    }

                    const edgeKey = `${edge.v1}-${edge.v2}`;
                    processedEdges.add(edgeKey);

                    const v1 = graph.vertices[edge.v1];
                    const v2 = graph.vertices[edge.v2];
                    const isPeripheryEdge = isEdgeInPeriphery(edge.v1, edge.v2);

                    const shouldBeCurved = view.showCurvedEdges && !isPeripheryEdge;

                    if (konvaShapes.edges[edgeKey]) {
                        // UPDATE EXISTING EDGE
                        const shape = konvaShapes.edges[edgeKey];

                        shape.stroke(isPeripheryEdge ? colors.peripheryColor : colors.edgeColor);
                        shape.strokeWidth(isPeripheryEdge ? 3 : 1.5);

                        if (shouldBeCurved) {
                            // Need to replace Line with Path for curves
                            if (shape instanceof Konva.Line) {
                                shape.destroy();
                                const control = calculateCurveControlPoint(v1, v2);
                                const pathData = `M ${v1.x},${v1.y} Q ${control.x},${control.y} ${v2.x},${v2.y}`;

                                const newPath = new Konva.Path({
                                    data: pathData,
                                    stroke: isPeripheryEdge ? colors.peripheryColor : colors.edgeColor,
                                    strokeWidth: isPeripheryEdge ? 3 : 1.5,
                                    lineCap: 'round',
                                    lineJoin: 'round'
                                });

                                edgeLayer.add(newPath);
                                konvaShapes.edges[edgeKey] = newPath;
                            } else if (shape instanceof Konva.Path) {
                                // Update existing path
                                const control = calculateCurveControlPoint(v1, v2);
                                const pathData = `M ${v1.x},${v1.y} Q ${control.x},${control.y} ${v2.x},${v2.y}`;
                                shape.data(pathData);
                            }
                        } else {
                            // Need straight edge
                            if (shape instanceof Konva.Path) {
                                shape.destroy();
                                const newLine = new Konva.Line({
                                    points: [v1.x, v1.y, v2.x, v2.y],
                                    stroke: isPeripheryEdge ? colors.peripheryColor : colors.edgeColor,
                                    strokeWidth: isPeripheryEdge ? 3 : 1.5,
                                    lineCap: 'round',
                                    lineJoin: 'round'
                                });

                                edgeLayer.add(newLine);
                                konvaShapes.edges[edgeKey] = newLine;
                            } else if (shape instanceof Konva.Line) {
                                // Update existing line
                                shape.points([v1.x, v1.y, v2.x, v2.y]);
                            }
                        }
                    } else {
                        // CREATE NEW EDGE
                        let shape;

                        if (shouldBeCurved) {
                            // Use Konva.Path for curved edges
                            const control = calculateCurveControlPoint(v1, v2);
                            const pathData = `M ${v1.x},${v1.y} Q ${control.x},${control.y} ${v2.x},${v2.y}`;

                            shape = new Konva.Path({
                                data: pathData,
                                stroke: isPeripheryEdge ? colors.peripheryColor : colors.edgeColor,
                                strokeWidth: isPeripheryEdge ? 3 : 1.5,
                                lineCap: 'round',
                                lineJoin: 'round'
                            });
                        } else {
                            // Use Konva.Line for straight edges
                            shape = new Konva.Line({
                                points: [v1.x, v1.y, v2.x, v2.y],
                                stroke: isPeripheryEdge ? colors.peripheryColor : colors.edgeColor,
                                strokeWidth: isPeripheryEdge ? 3 : 1.5,
                                lineCap: 'round',
                                lineJoin: 'round'
                            });
                        }

                        edgeLayer.add(shape);
                        konvaShapes.edges[edgeKey] = shape;
                    }
                }

                // Remove shapes for edges that no longer exist or are not visible
                for (const key in konvaShapes.edges) {
                    if (!processedEdges.has(key)) {
                        konvaShapes.edges[key].destroy();
                        delete konvaShapes.edges[key];
                    }
                }

                edgeLayer.batchDraw();
            }

            function drawFaces() {
                const processedFaces = new Set();

                for (let i = 0; i < graph.faces.length; i++) {
                    const face = graph.faces[i];

                    if (face.length !== 3) continue;
                    if (face.some(id => id > view.maxVisibleVertex)) continue;

                    processedFaces.add(i);

                    const points = [];
                    for (const vertexId of face) {
                        const vertex = graph.vertices[vertexId];
                        points.push(vertex.x, vertex.y);
                    }

                    if (konvaShapes.faces[i]) {
                        konvaShapes.faces[i].points(points);
                    } else {
                        const polygon = new Konva.Line({
                            points: points,
                            fill: '#90EE90',
                            opacity: 0.05,
                            closed: true
                        });

                        faceLayer.add(polygon);
                        konvaShapes.faces[i] = polygon;
                    }
                }

                for (const key in konvaShapes.faces) {
                    if (!processedFaces.has(parseInt(key))) {
                        konvaShapes.faces[key].destroy();
                        delete konvaShapes.faces[key];
                    }
                }

                faceLayer.batchDraw();
            }

            function draw() {
                try {
                    drawFaces();
                    drawEdges();
                    drawVertices();
                    stage.batchDraw();
                } catch (error) {
                    log('Error in draw function', error);
                    showAlert('Rendering error occurred', 'error');
                }
            }

            // ===================================================================
            // CORE GEOMETRIC FUNCTIONS
            // ===================================================================

            function doEdgesCross(x1, y1, x2, y2, x3, y3, x4, y4) {
                const dx1 = x2 - x1;
                const dy1 = y2 - y1;
                const dx2 = x4 - x3;
                const dy2 = y4 - y3;

                const denom = dx1 * dy2 - dy1 * dx2;
                if (Math.abs(denom) < 1e-10) return false;

                const dx3 = x3 - x1;
                const dy3 = y3 - y1;

                const t = (dx3 * dy2 - dy3 * dx2) / denom;
                const u = (dx3 * dy1 - dy3 * dx1) / denom;

                const epsilon = 0.001;
                return (t > epsilon && t < 1 - epsilon) && (u > epsilon && u < 1 - epsilon);
            }

            function calculateDistance(v1, v2) {
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function calculateAngle(p1, center, p2) {
                const v1x = p1.x - center.x;
                const v1y = p1.y - center.y;
                const v2x = p2.x - center.x;
                const v2y = p2.y - center.y;

                const dot = v1x * v2x + v1y * v2y;
                const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);

                if (mag1 === 0 || mag2 === 0) return Math.PI;

                const cosAngle = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
                return Math.acos(cosAngle);
            }

            function calculateCurveControlPoint(v1, v2) {
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;

                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const len = Math.sqrt(dx * dx + dy * dy);

                if (len === 0) return { x: midX, y: midY };

                const perpX = -dy / len;
                const perpY = dx / len;
                const curveAmount = len * CONFIG.CURVE_FACTOR;

                return {
                    x: midX + perpX * curveAmount,
                    y: midY + perpY * curveAmount
                };
            }

            function pointToSegmentDistance(point, segmentStart, segmentEnd) {
                const dx = segmentEnd.x - segmentStart.x;
                const dy = segmentEnd.y - segmentStart.y;

                if (dx === 0 && dy === 0) {
                    return calculateDistance(point, segmentStart);
                }

                const t = Math.max(0, Math.min(1,
                    ((point.x - segmentStart.x) * dx + (point.y - segmentStart.y) * dy) / (dx * dx + dy * dy)
                ));

                const closestPoint = {
                    x: segmentStart.x + t * dx,
                    y: segmentStart.y + t * dy
                };

                return calculateDistance(point, closestPoint);
            }

            // ===================================================================
            // SPATIAL INDEXING WITH QUADTREE
            // ===================================================================

            function updateQuadTree() {
                const bounds = {
                    x: 0,
                    y: 0,
                    width: stage.width(),
                    height: stage.height()
                };

                quadTree = new QuadTree(bounds, 4);

                for (const vertex of graph.vertices) {
                    quadTree.insert(vertex);
                }
            }

            // ===================================================================
            // GRAPH ALGORITHMS
            // ===================================================================

            function updateAdjacencyMatrix() {
                const n = graph.vertices.length;
                graph.adjacencyMatrix = Array(n).fill().map(() => Array(n).fill(0));

                graph.edges = graph.edges.filter(edge =>
                    edge.v1 >= 0 && edge.v1 < n &&
                    edge.v2 >= 0 && edge.v2 < n &&
                    edge.v1 !== edge.v2
                );

                for (const edge of graph.edges) {
                    graph.adjacencyMatrix[edge.v1][edge.v2] = 1;
                    graph.adjacencyMatrix[edge.v2][edge.v1] = 1;
                }
            }

            function getNeighbors(vertexId) {
                if (!graph.adjacencyMatrix || vertexId >= graph.adjacencyMatrix.length) {
                    const neighbors = [];
                    for (const edge of graph.edges) {
                        if (edge.v1 === vertexId) neighbors.push(edge.v2);
                        else if (edge.v2 === vertexId) neighbors.push(edge.v1);
                    }
                    return neighbors;
                }

                const neighbors = [];
                for (let i = 0; i < graph.adjacencyMatrix[vertexId].length; i++) {
                    if (graph.adjacencyMatrix[vertexId][i] === 1) {
                        neighbors.push(i);
                    }
                }
                return neighbors;
            }

            function edgeExists(v1, v2) {
                if (graph.adjacencyMatrix && v1 < graph.adjacencyMatrix.length && v2 < graph.adjacencyMatrix.length) {
                    return graph.adjacencyMatrix[v1][v2] === 1;
                }
                return graph.edges.some(edge =>
                    (edge.v1 === v1 && edge.v2 === v2) || (edge.v1 === v2 && edge.v2 === v1)
                );
            }

            function detectFaces() {
                graph.faces = [];

                for (let i = 0; i < graph.vertices.length; i++) {
                    const neighbors_i = getNeighbors(i);

                    for (let j = 0; j < neighbors_i.length; j++) {
                        const neighbor_j = neighbors_i[j];
                        if (neighbor_j <= i) continue;

                        const neighbors_j = getNeighbors(neighbor_j);

                        for (let k = 0; k < neighbors_j.length; k++) {
                            const neighbor_k = neighbors_j[k];
                            if (neighbor_k <= neighbor_j) continue;

                            if (edgeExists(i, neighbor_k)) {
                                graph.faces.push([i, neighbor_j, neighbor_k]);
                            }
                        }
                    }
                }

                log('Faces detected', { count: graph.faces.length });
            }

            function findConvexHull() {
                if (graph.vertices.length < 3) {
                    return graph.vertices.map(v => v.id);
                }

                let start = 0;
                for (let i = 1; i < graph.vertices.length; i++) {
                    if (graph.vertices[i].y < graph.vertices[start].y ||
                        (graph.vertices[i].y === graph.vertices[start].y &&
                            graph.vertices[i].x < graph.vertices[start].x)) {
                        start = i;
                    }
                }

                const points = graph.vertices.map((v, i) => ({ ...v, id: i }));
                const startPoint = points[start];

                points.sort((a, b) => {
                    if (a.id === start) return -1;
                    if (b.id === start) return 1;

                    const angleA = Math.atan2(a.y - startPoint.y, a.x - startPoint.x);
                    const angleB = Math.atan2(b.y - startPoint.y, b.x - startPoint.x);

                    if (Math.abs(angleA - angleB) < CONFIG.CONVEX_HULL_EPSILON) {
                        const distA = (a.x - startPoint.x) ** 2 + (a.y - startPoint.y) ** 2;
                        const distB = (b.x - startPoint.x) ** 2 + (b.y - startPoint.y) ** 2;
                        return distA - distB;
                    }

                    return angleA - angleB;
                });

                const hull = [points[0], points[1]];

                for (let i = 2; i < points.length; i++) {
                    while (hull.length > 1 &&
                        crossProduct(hull[hull.length - 2], hull[hull.length - 1], points[i]) <= 0) {
                        hull.pop();
                    }
                    hull.push(points[i]);
                }

                return hull.map(p => p.id);
            }

            function crossProduct(o, a, b) {
                return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
            }

            // ===================================================================
            // FIXED PHYSICS-BASED LAYOUT WITH MATTER.JS
            // ===================================================================

            function calculateRepulsionForce(bodyA, bodyB) {
                const dx = bodyB.position.x - bodyA.position.x;
                const dy = bodyB.position.y - bodyA.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1) return { a: { x: 0, y: 0 }, b: { x: 0, y: 0 } };

                const strength = CONFIG.REPULSION_STRENGTH / (distance * distance);
                const forceX = (dx / distance) * strength;
                const forceY = (dy / distance) * strength;

                return {
                    a: { x: -forceX, y: -forceY },
                    b: { x: forceX, y: forceY }
                };
            }

            function fixGraph() {
                if (graph.vertices.length <= 3) {
                    showAlert('Need more than 3 vertices to apply physics layout', 'info');
                    return;
                }

                showLoading(true, 'Applying physics-based layout optimization...');
                log('Starting Matter.js physics layout');

                // Stop any existing physics simulation
                if (physicsRunner) {
                    Matter.Runner.stop(physicsRunner);
                    physicsRunner = null;
                }
                if (physicsEngine) {
                    Matter.Engine.clear(physicsEngine);
                    physicsEngine = null;
                }

                // Create new Matter.js engine
                physicsEngine = Matter.Engine.create();
                physicsEngine.gravity.scale = 0; // Disable gravity for 2D layout

                // Create vertex bodies with proper collision boundaries
                const bodies = graph.vertices.map(v => {
                    const radius = getVertexRadius(v.id) + CONFIG.COLLISION_MARGIN;
                    const body = Matter.Bodies.circle(v.x, v.y, radius, {
                        id: v.id,
                        isStatic: graph.periphery.includes(v.id), // Pin periphery vertices
                        restitution: CONFIG.PHYSICS_RESTITUTION,
                        friction: CONFIG.PHYSICS_FRICTION,
                        frictionAir: 0.01
                    });
                    return body;
                });

                // Add bodies to the world
                Matter.Composite.add(physicsEngine.world, bodies);

                // Create spring constraints for edges
                const constraints = graph.edges.map(edge => {
                    return Matter.Constraint.create({
                        bodyA: bodies[edge.v1],
                        bodyB: bodies[edge.v2],
                        length: CONFIG.MIN_EDGE_LENGTH * 2,
                        stiffness: CONFIG.PHYSICS_STIFFNESS,
                        damping: CONFIG.PHYSICS_DAMPING
                    });
                });

                Matter.Composite.add(physicsEngine.world, constraints);

                // Add repulsion forces between all vertices
                Matter.Events.on(physicsEngine, 'beforeUpdate', function () {
                    for (let i = 0; i < bodies.length; i++) {
                        if (bodies[i].isStatic) continue;

                        for (let j = i + 1; j < bodies.length; j++) {
                            if (bodies[j].isStatic) continue;

                            const force = calculateRepulsionForce(bodies[i], bodies[j]);
                            Matter.Body.applyForce(bodies[i], bodies[i].position, force.a);
                            Matter.Body.applyForce(bodies[j], bodies[j].position, force.b);
                        }
                    }
                });

                // Create runner
                physicsRunner = Matter.Runner.create();
                let iterations = 0;

                // Update visualization during simulation
                Matter.Events.on(physicsRunner, 'tick', function () {
                    iterations++;

                    // Update vertex positions from physics
                    bodies.forEach((body, i) => {
                        if (!body.isStatic) {
                            graph.vertices[i].x = body.position.x;
                            graph.vertices[i].y = body.position.y;
                        }
                    });

                    // Update rendering in real-time
                    if (iterations % 10 === 0) {
                        updateVertexPositions();
                    }

                    // Stop after iterations or time limit
                    if (iterations >= CONFIG.PHYSICS_ITERATIONS ||
                        physicsEngine.timing.timestamp > CONFIG.PHYSICS_TIME_LIMIT) {
                        Matter.Runner.stop(physicsRunner);

                        // Final update
                        updateQuadTree();
                        detectFaces();
                        updateGraphInfo();
                        draw();

                        showLoading(false);

                        const overlaps = findAllOverlaps();
                        const crossings = findAllCrossings();

                        if (overlaps.length === 0 && crossings.length === 0) {
                            showAlert('Perfect layout achieved with physics optimization!', 'success');
                        } else {
                            showAlert(`Layout improved. ${overlaps.length} overlaps, ${crossings.length} crossings remaining.`, 'warning');
                        }

                        log('Physics layout completed', {
                            iterations: iterations,
                            overlaps: overlaps.length,
                            crossings: crossings.length
                        });
                    }
                });

                // Start the runner
                Matter.Runner.run(physicsRunner, physicsEngine);
            }

            // ===================================================================
            // IMPROVED ANGULAR RESOLUTION ENFORCEMENT
            // ===================================================================

            function enforceAngularResolution(position, connectedVertices) {
                const MIN_ANGLE = CONFIG.MIN_ANGLE_THRESHOLD; // PI/4 = 45 degrees
                const angles = [];

                // Calculate all angles from position to connected vertices
                for (const vId of connectedVertices) {
                    const v = graph.vertices[vId];
                    const angle = Math.atan2(v.y - position.y, v.x - position.x);
                    angles.push({ id: vId, angle: angle });
                }

                // Sort by angle
                angles.sort((a, b) => a.angle - b.angle);

                // Check minimum angular separation
                for (let i = 0; i < angles.length; i++) {
                    const next = (i + 1) % angles.length;
                    let angleDiff = angles[next].angle - angles[i].angle;

                    // Handle wraparound
                    if (angleDiff < 0) angleDiff += 2 * Math.PI;

                    if (angleDiff < MIN_ANGLE) {
                        // Adjust position to increase angular separation
                        const adjustment = calculateAngularAdjustment(
                            position,
                            graph.vertices[angles[i].id],
                            graph.vertices[angles[next].id],
                            MIN_ANGLE
                        );
                        position.x += adjustment.x;
                        position.y += adjustment.y;
                    }
                }

                return position;
            }

            function calculateAngularAdjustment(position, v1, v2, targetAngle) {
                const currentAngle = calculateAngle(v1, position, v2);
                const angleDeficit = targetAngle - currentAngle;

                if (angleDeficit <= 0) return { x: 0, y: 0 };

                // Calculate the bisector direction
                const angle1 = Math.atan2(v1.y - position.y, v1.x - position.x);
                const angle2 = Math.atan2(v2.y - position.y, v2.x - position.x);
                const bisectorAngle = (angle1 + angle2) / 2 + Math.PI;

                // Move along the bisector to increase angle
                const adjustmentDistance = angleDeficit * 50; // Scale factor

                return {
                    x: Math.cos(bisectorAngle) * adjustmentDistance,
                    y: Math.sin(bisectorAngle) * adjustmentDistance
                };
            }

            // ===================================================================
            // ENHANCED SMART PLACEMENT SYSTEM WITH IMPROVED WEIGHTS
            // ===================================================================

            function evaluatePositionQuality(position, connectedVertices, newVertexId) {
                let score = 0;
                const weights = CONFIG.POSITION_QUALITY_WEIGHTS;

                const overlapPenalty = calculateOverlapPenalty(position, newVertexId);
                score -= overlapPenalty * weights.overlap;

                const minDistPenalty = calculateMinDistancePenalty(position, newVertexId);
                score -= minDistPenalty * weights.minDistance;

                const angleQuality = calculateAngleQuality(position, connectedVertices);
                score += angleQuality * weights.angleQuality;

                const edgeLengthScore = calculateEdgeLengthScore(position, connectedVertices);
                score += edgeLengthScore * weights.edgeLengthVariance;

                const peripheryScore = calculatePeripheryDistanceScore(position, connectedVertices);
                score += peripheryScore * weights.peripheryDistance;

                const vertexEdgePenalty = calculateVertexEdgeDistancePenalty(position, newVertexId);
                score -= vertexEdgePenalty * weights.vertexEdgeDistance;

                if (wouldCreateCrossing(position, connectedVertices)) {
                    score -= 10000;
                }

                return score;
            }

            function calculateOverlapPenalty(position, newVertexId) {
                let penalty = 0;
                const newRadius = getVertexRadius(newVertexId);

                for (let i = 0; i < graph.vertices.length; i++) {
                    const existing = graph.vertices[i];
                    const distance = calculateDistance(position, existing);
                    const existingRadius = getVertexRadius(i);
                    const minDistance = newRadius + existingRadius + CONFIG.OVERLAP_SAFETY_MARGIN;

                    if (distance < minDistance) {
                        const overlapAmount = minDistance - distance;
                        penalty += Math.pow(overlapAmount / minDistance, 2);
                    }
                }

                return penalty;
            }

            function calculateMinDistancePenalty(position, newVertexId) {
                let minDistance = Infinity;
                const newRadius = getVertexRadius(newVertexId);

                for (let i = 0; i < graph.vertices.length; i++) {
                    const existing = graph.vertices[i];
                    const distance = calculateDistance(position, existing);
                    minDistance = Math.min(minDistance, distance);
                }

                const idealMinDistance = newRadius * 2 + CONFIG.OVERLAP_SAFETY_MARGIN;
                if (minDistance < idealMinDistance) {
                    return (idealMinDistance - minDistance) / idealMinDistance;
                }

                return 0;
            }

            function calculateAngleQuality(position, connectedVertices) {
                if (connectedVertices.length < 2) return 0;

                let totalAngleScore = 0;
                const idealAngle = (2 * Math.PI) / connectedVertices.length;

                for (let i = 0; i < connectedVertices.length; i++) {
                    const prev = graph.vertices[connectedVertices[i]];
                    const next = graph.vertices[connectedVertices[(i + 1) % connectedVertices.length]];

                    const angle = calculateAngle(prev, position, next);
                    const angleDiff = Math.abs(angle - idealAngle);

                    const angleScore = 1 - (angleDiff / Math.PI);
                    totalAngleScore += Math.max(0, angleScore);
                }

                return totalAngleScore / connectedVertices.length;
            }

            function calculateEdgeLengthScore(position, connectedVertices) {
                if (connectedVertices.length === 0) return 0;

                const edgeLengths = connectedVertices.map(vId =>
                    calculateDistance(position, graph.vertices[vId])
                );

                const avgLength = edgeLengths.reduce((a, b) => a + b, 0) / edgeLengths.length;
                const targetLength = calculateAverageTargetEdgeLength();

                const lengthScore = 1 - Math.abs(avgLength - targetLength) / targetLength;

                const variance = edgeLengths.reduce((sum, len) =>
                    sum + Math.pow(len - avgLength, 2), 0) / edgeLengths.length;
                const varianceScore = 1 - Math.min(1, variance / (targetLength * targetLength));

                return (lengthScore + varianceScore) / 2;
            }

            function calculatePeripheryDistanceScore(position, connectedVertices) {
                if (connectedVertices.length === 0) return 0;

                const center = calculateSegmentCenter(connectedVertices);
                const distance = calculateDistance(position, center);
                const targetDistance = calculateTargetDistance(connectedVertices);

                const distanceScore = 1 - Math.abs(distance - targetDistance) / targetDistance;
                return Math.max(0, distanceScore);
            }

            function calculateVertexEdgeDistancePenalty(position, newVertexId) {
                let penalty = 0;
                const safetyMargin = CONFIG.VERTEX_EDGE_SAFETY_MARGIN;

                for (const edge of graph.edges) {
                    const segmentStart = graph.vertices[edge.v1];
                    const segmentEnd = graph.vertices[edge.v2];

                    const distance = pointToSegmentDistance(position, segmentStart, segmentEnd);

                    if (distance < safetyMargin) {
                        const violationAmount = safetyMargin - distance;
                        penalty += Math.pow(violationAmount / safetyMargin, 2);
                    }
                }

                return penalty;
            }

            // ===================================================================
            // VORONOI-BASED CANDIDATE PLACEMENT
            // ===================================================================

            function generateCandidatePositions(basePosition, connectedVertices) {
                const candidates = [];

                candidates.push(basePosition);

                if (graph.vertices.length < 4) {
                    log('Too few vertices for Voronoi, using simple radial placement');

                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                        for (let radius = 50; radius <= 200; radius += 50) {
                            candidates.push({
                                x: basePosition.x + Math.cos(angle) * radius,
                                y: basePosition.y + Math.sin(angle) * radius
                            });
                        }
                    }

                    return candidates;
                }

                try {
                    log('Generating Voronoi-based candidate positions');

                    const points = graph.vertices.map(v => [v.x, v.y]);
                    const delaunay = d3.Delaunay.from(points);
                    const voronoi = delaunay.voronoi([0, 0, stage.width(), stage.height()]);

                    const graphCenter = calculateGraphCenter();

                    const connectedCells = [];
                    for (const vId of connectedVertices) {
                        const cellVertices = voronoi.cellPolygon(vId);
                        if (cellVertices) {
                            connectedCells.push({
                                vertexId: vId,
                                vertex: graph.vertices[vId],
                                polygon: cellVertices
                            });
                        }
                    }

                    log(`Found ${connectedCells.length} Voronoi cells for connected vertices`);

                    for (const cell of connectedCells) {
                        const { vertex, polygon } = cell;

                        if (!polygon || polygon.length < 3) continue;

                        for (let i = 0; i < polygon.length; i++) {
                            const edgeStart = { x: polygon[i][0], y: polygon[i][1] };
                            const edgeEnd = { x: polygon[(i + 1) % polygon.length][0], y: polygon[(i + 1) % polygon.length][1] };

                            const edgeMidpoint = {
                                x: (edgeStart.x + edgeEnd.x) / 2,
                                y: (edgeStart.y + edgeEnd.y) / 2
                            };

                            const toCenter = {
                                x: graphCenter.x - vertex.x,
                                y: graphCenter.y - vertex.y
                            };

                            const toMidpoint = {
                                x: edgeMidpoint.x - vertex.x,
                                y: edgeMidpoint.y - vertex.y
                            };

                            const dotProduct = toCenter.x * toMidpoint.x + toCenter.y * toMidpoint.y;

                            if (dotProduct < 0) {
                                const samplesPerEdge = 3;
                                for (let t = 0.2; t <= 0.8; t += 0.6 / (samplesPerEdge - 1)) {
                                    const samplePoint = {
                                        x: edgeStart.x + t * (edgeEnd.x - edgeStart.x),
                                        y: edgeStart.y + t * (edgeEnd.y - edgeStart.y)
                                    };

                                    if (samplePoint.x >= 20 && samplePoint.x <= stage.width() - 20 &&
                                        samplePoint.y >= 20 && samplePoint.y <= stage.height() - 20) {
                                        candidates.push(samplePoint);
                                    }
                                }

                                if (edgeMidpoint.x >= 20 && edgeMidpoint.x <= stage.width() - 20 &&
                                    edgeMidpoint.y >= 20 && edgeMidpoint.y <= stage.height() - 20) {
                                    candidates.push(edgeMidpoint);
                                }
                            }
                        }
                    }

                    const triangles = delaunay.triangles;

                    for (let i = 0; i < triangles.length; i += 3) {
                        const p1 = points[triangles[i]];
                        const p2 = points[triangles[i + 1]];
                        const p3 = points[triangles[i + 2]];

                        const circumcenter = calculateCircumcenter(
                            { x: p1[0], y: p1[1] },
                            { x: p2[0], y: p2[1] },
                            { x: p3[0], y: p3[1] }
                        );

                        if (circumcenter) {
                            let isOutward = false;
                            for (const vId of connectedVertices) {
                                const vertex = graph.vertices[vId];
                                const toCenterVec = {
                                    x: graphCenter.x - vertex.x,
                                    y: graphCenter.y - vertex.y
                                };
                                const toCircumcenterVec = {
                                    x: circumcenter.x - vertex.x,
                                    y: circumcenter.y - vertex.y
                                };

                                const dot = toCenterVec.x * toCircumcenterVec.x + toCenterVec.y * toCircumcenterVec.y;
                                if (dot < 0) {
                                    isOutward = true;
                                    break;
                                }
                            }

                            if (isOutward &&
                                circumcenter.x >= 20 && circumcenter.x <= stage.width() - 20 &&
                                circumcenter.y >= 20 && circumcenter.y <= stage.height() - 20) {
                                candidates.push(circumcenter);
                            }
                        }
                    }

                    const outwardNormal = calculateOutwardNormal(connectedVertices);
                    for (let dist = 80; dist <= 300; dist += 40) {
                        candidates.push({
                            x: basePosition.x + outwardNormal.x * dist,
                            y: basePosition.y + outwardNormal.y * dist
                        });
                    }

                    log(`Generated ${candidates.length} Voronoi-based candidate positions`);

                } catch (error) {
                    log('Error in Voronoi computation, falling back to radial placement', error);

                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                        for (let radius = 60; radius <= 250; radius += 40) {
                            candidates.push({
                                x: basePosition.x + Math.cos(angle) * radius,
                                y: basePosition.y + Math.sin(angle) * radius
                            });
                        }
                    }
                }

                return candidates;
            }

            function calculateCircumcenter(p1, p2, p3) {
                const ax = p1.x, ay = p1.y;
                const bx = p2.x, by = p2.y;
                const cx = p3.x, cy = p3.y;

                const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));

                if (Math.abs(d) < 1e-10) {
                    return null;
                }

                const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
                const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;

                return { x: ux, y: uy };
            }

            function findBestPosition(basePosition, connectedVertices, newVertexId) {
                let candidates = generateCandidatePositions(basePosition, connectedVertices);

                // Apply angular resolution enforcement to each candidate
                candidates = candidates.map(candidate =>
                    enforceAngularResolution(candidate, connectedVertices)
                );

                let bestPosition = null;
                let bestScore = -Infinity;

                log(`Evaluating ${candidates.length} candidate positions with improved angular resolution`);

                for (const candidate of candidates) {
                    const score = evaluatePositionQuality(candidate, connectedVertices, newVertexId);

                    if (score > bestScore) {
                        bestScore = score;
                        bestPosition = candidate;
                    }
                }

                log(`Best position found with score: ${bestScore.toFixed(2)}`);

                // UNBREAKABLE VETO: Return null if no position is good enough
                const hasOverlaps = bestScore < -CONFIG.POSITION_QUALITY_WEIGHTS.overlap * 0.5;
                const hasCrossings = wouldCreateCrossing(bestPosition, connectedVertices);

                if (hasOverlaps || hasCrossings) {
                    log('UNBREAKABLE VETO: No acceptable position found - returning null');
                    return null;
                }

                return {
                    position: bestPosition || basePosition,
                    score: bestScore,
                    hasOverlaps: false
                };
            }

            // ===================================================================
            // GRAPH CONSTRUCTION FUNCTIONS
            // ===================================================================

            function addVertex(x, y) {
                if (graph.vertices.length >= CONFIG.MAX_VERTICES) {
                    throw new Error(`Maximum vertex limit of ${CONFIG.MAX_VERTICES} reached`);
                }

                const vertex = {
                    id: graph.vertices.length,
                    x: x,
                    y: y,
                    color: ((graph.vertices.length % 4) + 1)
                };

                graph.vertices.push(vertex);
                updateQuadTree();
                log(`Vertex V${vertex.id + 1} added at (${Math.round(x)}, ${Math.round(y)})`);
                return vertex;
            }

            function addEdge(v1, v2) {
                if (v1 === v2) return null;
                if (edgeExists(v1, v2)) return null;

                const edge = { v1, v2 };
                graph.edges.push(edge);

                const length = calculateDistance(graph.vertices[v1], graph.vertices[v2]);
                graph.edgeLengths.set(`${Math.min(v1, v2)}-${Math.max(v1, v2)}`, length);

                if (graph.adjacencyMatrix && v1 < graph.adjacencyMatrix.length && v2 < graph.adjacencyMatrix.length) {
                    graph.adjacencyMatrix[v1][v2] = 1;
                    graph.adjacencyMatrix[v2][v1] = 1;
                }

                log(`Edge V${v1 + 1}-V${v2 + 1} added`);
                return edge;
            }

            function getVerticesBetween(vpId, vqId) {
                const periphery = graph.periphery;
                const vpIdx = periphery.indexOf(vpId);
                const vqIdx = periphery.indexOf(vqId);

                if (vpIdx === -1 || vqIdx === -1) {
                    throw new Error('Selected vertices are not on the periphery');
                }

                if (vpIdx === vqIdx) {
                    throw new Error('Cannot select the same vertex twice');
                }

                let path1 = [];
                let path2 = [];

                if (vpIdx < vqIdx) {
                    path1 = periphery.slice(vpIdx, vqIdx + 1);
                } else {
                    path1 = [...periphery.slice(vpIdx), ...periphery.slice(0, vqIdx + 1)];
                }

                if (vpIdx < vqIdx) {
                    path2 = [...periphery.slice(0, vpIdx + 1).reverse(),
                    ...periphery.slice(vqIdx).reverse()];
                } else {
                    path2 = periphery.slice(vqIdx, vpIdx + 1).reverse();
                }

                let result = path1.length <= path2.length ? path1 : path2;

                if (result.length < 2) {
                    throw new Error('Selection must include at least 2 vertices (m > 1 constraint)');
                }

                const selectionPercentage = result.length / periphery.length;
                if (periphery.length > 6 && selectionPercentage > 0.8) {
                    log('Warning: Large selection detected', {
                        percentage: Math.round(selectionPercentage * 100) + '%',
                        vertices: result.length,
                        total: periphery.length
                    });
                    showAlert(`Warning: Large selection (${Math.round(selectionPercentage * 100)}% of periphery). This may affect graph regularity.`, 'warning');
                }

                return result;
            }

            function updatePeriphery(removedVertices, newVertexId) {
                try {
                    log('Updating periphery', {
                        removed: removedVertices.map(id => id + 1),
                        newVertex: newVertexId + 1,
                        currentPeriphery: graph.periphery.map(id => id + 1)
                    });

                    let minIdx = graph.periphery.length;
                    let maxIdx = -1;
                    let indices = [];

                    for (const vId of removedVertices) {
                        const idx = graph.periphery.indexOf(vId);
                        if (idx !== -1) {
                            indices.push(idx);
                            minIdx = Math.min(minIdx, idx);
                            maxIdx = Math.max(maxIdx, idx);
                        }
                    }

                    if (indices.length === 0) {
                        log('Warning: No vertices found in periphery, rebuilding');
                        graph.periphery = findConvexHull();
                        return graph.periphery;
                    }

                    indices.sort((a, b) => a - b);
                    let isWraparound = false;

                    if (indices.length > 1) {
                        for (let i = 1; i < indices.length; i++) {
                            if (indices[i] - indices[i - 1] > 1) {
                                isWraparound = true;
                                break;
                            }
                        }
                    }

                    let newPeriphery;

                    if (!isWraparound) {
                        newPeriphery = [
                            ...graph.periphery.slice(0, minIdx),
                            newVertexId,
                            ...graph.periphery.slice(maxIdx + 1)
                        ];
                    } else {
                        log('Complex wraparound detected, using convex hull');
                        graph.periphery = findConvexHull();
                        return graph.periphery;
                    }

                    if (newPeriphery.length < 3) {
                        log('Warning: New periphery too small, using convex hull');
                        newPeriphery = findConvexHull();
                    }

                    graph.periphery = newPeriphery;
                    log('Periphery updated successfully', { new: newPeriphery.map(id => id + 1) });

                    return newPeriphery;
                } catch (error) {
                    log('Error updating periphery, rebuilding', error);
                    graph.periphery = findConvexHull();
                    return graph.periphery;
                }
            }

            function calculateOptimalPosition(connectedVertices) {
                const middleIdx = Math.floor(connectedVertices.length / 2);
                const middleVertex = graph.vertices[connectedVertices[middleIdx]];

                let centerX = 0, centerY = 0;
                for (const id of connectedVertices) {
                    centerX += graph.vertices[id].x;
                    centerY += graph.vertices[id].y;
                }
                centerX /= connectedVertices.length;
                centerY /= connectedVertices.length;

                const outwardNormal = calculateOutwardNormal(connectedVertices);

                const baseDist = calculateTargetDistance(connectedVertices);
                let growthFactor = 1.2;

                if (graph.vertices.length > 4) {
                    growthFactor = 1.3 + (graph.vertices.length - 4) * 0.05;
                }

                const targetDistance = baseDist * growthFactor;

                const basePosition = {
                    x: centerX + outwardNormal.x * targetDistance,
                    y: centerY + outwardNormal.y * targetDistance
                };

                return basePosition;
            }

            function calculateOutwardNormal(verticesInBetween) {
                let normalX = 0, normalY = 0;

                for (let i = 0; i < verticesInBetween.length - 1; i++) {
                    const v1 = graph.vertices[verticesInBetween[i]];
                    const v2 = graph.vertices[verticesInBetween[i + 1]];

                    const edgeX = v2.x - v1.x;
                    const edgeY = v2.y - v1.y;

                    normalX += -edgeY;
                    normalY += edgeX;
                }

                const length = Math.sqrt(normalX * normalX + normalY * normalY);
                if (length > 0) {
                    normalX /= length;
                    normalY /= length;
                } else {
                    const center = calculateGraphCenter();
                    const segmentCenter = calculateSegmentCenter(verticesInBetween);
                    normalX = segmentCenter.x - center.x;
                    normalY = segmentCenter.y - center.y;
                    const len = Math.sqrt(normalX * normalX + normalY * normalY);
                    if (len > 0) {
                        normalX /= len;
                        normalY /= len;
                    }
                }

                const graphCenter = calculateGraphCenter();
                const segmentCenter = calculateSegmentCenter(verticesInBetween);

                const toCenterX = graphCenter.x - segmentCenter.x;
                const toCenterY = graphCenter.y - segmentCenter.y;

                if (normalX * toCenterX + normalY * toCenterY > 0) {
                    normalX = -normalX;
                    normalY = -normalY;
                }

                return { x: normalX, y: normalY };
            }

            function calculateGraphCenter() {
                if (graph.vertices.length === 0) return { x: 0, y: 0 };

                let x = 0, y = 0;
                for (const vertex of graph.vertices) {
                    x += vertex.x;
                    y += vertex.y;
                }
                return { x: x / graph.vertices.length, y: y / graph.vertices.length };
            }

            function calculateSegmentCenter(verticesInBetween) {
                let x = 0, y = 0;
                for (const id of verticesInBetween) {
                    x += graph.vertices[id].x;
                    y += graph.vertices[id].y;
                }
                return { x: x / verticesInBetween.length, y: y / verticesInBetween.length };
            }

            function expandGraphLayout(factor = 1.5) {
                const center = calculateGraphCenter();

                for (const vertex of graph.vertices) {
                    const dx = vertex.x - center.x;
                    const dy = vertex.y - center.y;

                    vertex.x = center.x + dx * factor;
                    vertex.y = center.y + dy * factor;
                }

                updateStoredEdgeLengths();
                updateQuadTree();

                log(`Graph expanded by factor ${factor} to prevent overlaps`);
            }

            function calculateTargetDistance(connectedVertices) {
                 let totalLength = 0;
                            let edgeCount = 0;

                            for (let i = 0; i < graph.periphery.length; i++) {
                                const v1 = graph.periphery[i];
                                const v2 = graph.periphery[(i + 1) % graph.periphery.length];
                                const edge1 = graph.vertices[v1];
                                const edge2 = graph.vertices[v2];
                                totalLength += calculateDistance(edge1, edge2);
                                edgeCount++;
                            }

                            const avgPeripheryLength = edgeCount > 0 ? totalLength / edgeCount : CONFIG.MIN_EDGE_LENGTH;

                            const maxRadius = Math.max(...connectedVertices.map(id => getVertexRadius(id)));
                            const newRadius = getVertexRadius(graph.vertices.length);
                            const minRequired = (maxRadius + newRadius) * 2 + CONFIG.OVERLAP_SAFETY_MARGIN;

                            return Math.max(minRequired,
                                Math.max(CONFIG.MIN_EDGE_LENGTH,
                                    Math.min(CONFIG.MAX_EDGE_LENGTH, avgPeripheryLength)));
                        }

                        function triangulateAfterAddition(newVertexId, connectedVertices) {
                            const newVertex = graph.vertices[newVertexId];

                            const middleIdx = Math.floor(connectedVertices.length / 2);

                            const sortedByDistance = connectedVertices
                                .map((vId, idx) => ({
                                    id: vId,
                                    originalIdx: idx,
                                    distance: calculateDistance(newVertex, graph.vertices[vId]),
                                    isMiddle: idx === middleIdx
                                }))
                                .sort((a, b) => {
                                    if (a.isMiddle) return -1;
                                    if (b.isMiddle) return 1;
                                    return a.distance - b.distance;
                                });

                            for (const vertex of sortedByDistance) {
                                addEdge(newVertexId, vertex.id);
                            }

                            for (let i = 0; i < connectedVertices.length - 1; i++) {
                                const v1 = connectedVertices[i];
                                const v2 = connectedVertices[i + 1];

                                if (!edgeExists(v1, v2)) {
                                    addEdge(v1, v2);
                                }
                            }

                            detectFaces();
                        }

                        function checkVpVqAngle(vpId, vqId) {
                            const vp = graph.vertices[vpId];
                            const vq = graph.vertices[vqId];
                            const center = calculateGraphCenter();

                            const angle = calculateAngle(vp, center, vq);

                            if (angle < Math.PI / 6) {
                                throw new Error('Selected angle is too narrow. Choose wider range.');
                            }

                            return true;
                        }

                        function wouldCreateCrossing(newVertex, connectedVertices) {
                            for (let i = 0; i < connectedVertices.length; i++) {
                                const v1 = connectedVertices[i];
                                const v1Pos = graph.vertices[v1];

                                for (const edge of graph.edges) {
                                    if (edge.v1 === v1 || edge.v2 === v1) continue;

                                    const v2Pos = graph.vertices[edge.v1];
                                    const v3Pos = graph.vertices[edge.v2];

                                    if (doEdgesCross(newVertex.x, newVertex.y, v1Pos.x, v1Pos.y,
                                        v2Pos.x, v2Pos.y, v3Pos.x, v3Pos.y)) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        }

                        function wouldCreateOverlap(newVertex) {
                            for (let id = 0; id < graph.vertices.length; id++) {
                                const existing = graph.vertices[id];
                                const dist = calculateDistance(newVertex, existing);

                                const newVertexRadius = getVertexRadius(graph.vertices.length);
                                const existingRadius = getVertexRadius(id);

                                const safetyMargin = graph.vertices.length <= 6 ? 15 : CONFIG.OVERLAP_SAFETY_MARGIN;
                                const minAllowedDist = newVertexRadius + existingRadius + safetyMargin;

                                if (dist < minAllowedDist) {
                                    return true;
                                }
                            }
                            return false;
                        }

                        function calculateAverageTargetEdgeLength() {
                            if (graph.edgeLengths.size === 0) {
                                return (CONFIG.MIN_EDGE_LENGTH + CONFIG.MAX_EDGE_LENGTH) / 2;
                            }

                            let total = 0;
                            let count = 0;

                            for (const length of graph.edgeLengths.values()) {
                                total += length;
                                count++;
                            }

                            return total / count;
                        }

                        function updateStoredEdgeLengths() {
                            graph.edgeLengths.clear();

                            for (const edge of graph.edges) {
                                const length = calculateDistance(graph.vertices[edge.v1], graph.vertices[edge.v2]);
                                const key = `${Math.min(edge.v1, edge.v2)}-${Math.max(edge.v1, edge.v2)}`;
                                graph.edgeLengths.set(key, length);
                            }
                        }

                        // ===================================================================
                        // MAIN GRAPH OPERATIONS
                        // ===================================================================

                        function startGraph() {
                            graph = {
                                vertices: [],
                                edges: [],
                                faces: [],
                                periphery: [],
                                adjacencyMatrix: null,
                                edgeLengths: new Map()
                            };

                            // Reset physics if active
                            if (physicsRunner) {
                                Matter.Runner.stop(physicsRunner);
                                physicsRunner = null;
                            }
                            if (physicsEngine) {
                                Matter.Engine.clear(physicsEngine);
                                physicsEngine = null;
                            }

                            const centerX = stage.width() / 2;
                            const centerY = stage.height() / 2;

                            const triangleRadius = CONFIG.INITIAL_TRIANGLE_SIZE;

                            const v1 = addVertex(centerX, centerY - triangleRadius);
                            const v2 = addVertex(
                                centerX - triangleRadius * Math.cos(Math.PI / 6),
                                centerY + triangleRadius * Math.sin(Math.PI / 6)
                            );
                            const v3 = addVertex(
                                centerX + triangleRadius * Math.cos(Math.PI / 6),
                                centerY + triangleRadius * Math.sin(Math.PI / 6)
                            );

                            addEdge(0, 1);
                            addEdge(1, 2);
                            addEdge(2, 0);

                            graph.periphery = [0, 2, 1];

                            updateAdjacencyMatrix();
                            detectFaces();

                            updateStatus('Initial triangle V1-V2-V3 created. Click on any two red vertices to add V4.');
                            updateGraphInfo();
                            enableButtons();
                            centerGraph();

                            showAlert('Triangle created! Click two red periphery vertices to add V4', 'success');
                            log('Initial triangle created', {
                                vertices: 3,
                                edges: 3,
                                faces: 1,
                                triangleRadius: triangleRadius
                            });

                            draw();
                        }

                        function startAddVertex() {
                            if (graph.periphery.length < 2) {
                                showAlert('Need at least 2 vertices in periphery', 'error');
                                return;
                            }

                            if (graph.vertices.length >= CONFIG.MAX_VERTICES) {
                                showAlert(`Maximum vertex limit of ${CONFIG.MAX_VERTICES} reached`, 'error');
                                return;
                            }

                            selection.mode = 'add';
                            selection.vertices = [];
                            selection.firstVertex = null;
                            selection.secondVertex = null;

                            updateStatus('Select first periphery vertex (Vp) - red vertices are on the periphery');
                            updateSelectionInfo();
                            showAlert('Click any two red vertices to select range for new vertex', 'info');

                            draw();
                            log('Started vertex addition mode');
                        }

                        // EXHAUSTIVE CENSUS implementation for addRandomVertex
                        function addRandomVertex() {
                            if (graph.periphery.length < 2) {
                                showAlert('Need at least 2 vertices in periphery', 'error');
                                return;
                            }

                            if (graph.vertices.length >= CONFIG.MAX_VERTICES) {
                                showAlert(`Maximum vertex limit of ${CONFIG.MAX_VERTICES} reached`, 'error');
                                return;
                            }

                            showLoading(true, 'Exhaustive census: evaluating all periphery pairs...');

                            setTimeout(() => {
                                try {
                                    const p = graph.periphery;
                                    let validPairs = [];

                                    // EXHAUSTIVE CENSUS: Check all possible pairs
                                    log(`Exhaustive census: checking ${p.length * (p.length - 1) / 2} possible pairs`);

                                    for (let i = 0; i < p.length; i++) {
                                        for (let j = i + 1; j < p.length; j++) {
                                            const vp = p[i];
                                            const vq = p[j];

                                            try {
                                                checkVpVqAngle(vp, vq);
                                                const vertices = getVerticesBetween(vp, vq);

                                                if (vertices.length >= 2 && vertices.length <= Math.max(3, p.length * 0.6)) {
                                                    // Test if we can find a good position
                                                    const basePosition = calculateOptimalPosition(vertices);
                                                    const result = findBestPosition(basePosition, vertices, graph.vertices.length);

                                                    if (result !== null) {
                                                        validPairs.push({
                                                            vp, vq,
                                                            vertices,
                                                            score: result.score,
                                                            selectionSize: vertices.length
                                                        });
                                                    }
                                                }
                                            } catch (e) {
                                                // Invalid pair, skip
                                                continue;
                                            }
                                        }
                                    }

                                    log(`Exhaustive census complete: found ${validPairs.length} valid pairs`);

                                    if (validPairs.length === 0) {
                                        throw new Error(`No valid vertex placement found after exhaustive census of ${p.length * (p.length - 1) / 2} pairs. The graph may be too dense. Try using "Fix Graph" first.`);
                                    }

                                    // Sort by score and selection size preference
                                    validPairs.sort((a, b) => {
                                        // Prefer smaller selections with higher scores
                                        const scoreWeightA = a.score - a.selectionSize * 5;
                                        const scoreWeightB = b.score - b.selectionSize * 5;
                                        return scoreWeightB - scoreWeightA;
                                    });

                                    // Pick from top candidates randomly
                                    const topCandidates = validPairs.slice(0, Math.min(5, validPairs.length));
                                    const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];

                                    log('Random selection from exhaustive census', {
                                        totalValid: validPairs.length,
                                        selected: {
                                            vp: selected.vp + 1,
                                            vq: selected.vq + 1,
                                            score: selected.score.toFixed(2),
                                            selectionSize: selected.selectionSize
                                        }
                                    });

                                    addNewVertex(selected.vp, selected.vq);

                                } catch (error) {
                                    log('Error in exhaustive census random vertex addition', error);
                                    showAlert(error.message, 'error');
                                } finally {
                                    showLoading(false);
                                }
                            }, 10);
                        }

                        // UNBREAKABLE VETO and VETO, REDRAW, RETRY implementation
                        function addNewVertex(vpId, vqId) {
                            try {
                                log('Adding new vertex with Voronoi-based placement + Unbreakable Veto', { vp: vpId + 1, vq: vqId + 1 });

                                if (!graph.periphery.includes(vpId) || !graph.periphery.includes(vqId)) {
                                    throw new Error('Selected vertices must be on the periphery');
                                }

                                if (vpId === vqId) {
                                    throw new Error('Must select two different vertices');
                                }

                                const vp = graph.vertices[vpId];
                                const vq = graph.vertices[vqId];
                                const angle = calculateAngle(vp, calculateGraphCenter(), vq);
                                if (angle < Math.PI / 8) {
                                    throw new Error('Selected angle is too narrow. Choose vertices further apart.');
                                }

                                const connectedVertices = getVerticesBetween(vpId, vqId);
                                log('Connected vertices', connectedVertices.map(id => id + 1));

                                showLoading(true, 'Evaluating Voronoi-based optimal position...');

                                const basePosition = calculateOptimalPosition(connectedVertices);
                                const newVertexId = graph.vertices.length;

                                const result = findBestPosition(basePosition, connectedVertices, newVertexId);

                                // UNBREAKABLE VETO: Check if placement failed
                                if (result === null) {
                                    log('UNBREAKABLE VETO triggered - no acceptable position found');
                                    showLoading(true, 'VETO: Redrawing graph and retrying...');

                                    // VETO, REDRAW, RETRY sequence
                                    redrawGraph(true);

                                    setTimeout(() => {
                                        // Retry after redraw
                                        const newBasePosition = calculateOptimalPosition(connectedVertices);
                                        const retryResult = findBestPosition(newBasePosition, connectedVertices, newVertexId);

                                        if (retryResult === null) {
                                            showLoading(false);
                                            throw new Error('VETO, REDRAW, RETRY sequence failed. Graph is too constrained for safe placement. Try manual selection or further layout optimization.');
                                        }

                                        // Proceed with retry result
                                        proceedWithPlacement(retryResult.position, newVertexId, connectedVertices, 'VETO-REDRAW-RETRY successful');
                                    }, 500);

                                    return;
                                }

                                // Proceed with normal placement
                                proceedWithPlacement(result.position, newVertexId, connectedVertices, 'Voronoi placement successful');

                            } catch (error) {
                                log('Error adding vertex', error);
                                showAlert('Error: ' + error.message, 'error');

                                selection.mode = 'none';
                                selection.vertices = [];
                                selection.firstVertex = null;
                                selection.secondVertex = null;
                                updateSelectionInfo();
                                draw();
                            } finally {
                                showLoading(false);
                            }
                        }

                        function proceedWithPlacement(position, newVertexId, connectedVertices, successMessage) {
                            showLoading(true, 'Placing vertex...');

                            const newVertex = addVertex(position.x, position.y);
                            triangulateAfterAddition(newVertex.id, connectedVertices);
                            updatePeriphery(connectedVertices, newVertex.id);
                            graph.periphery = findConvexHull();

                            updateAdjacencyMatrix();
                            updateQuadTree();
                            detectFaces();

                            updateGraphInfo();
                            updateStatus(`Vertex V${newVertex.id + 1} added successfully`);

                            selection.mode = 'none';
                            selection.vertices = [];
                            selection.firstVertex = null;
                            selection.secondVertex = null;
                            updateSelectionInfo();

                            draw();

                            showAlert(`Vertex V${newVertex.id + 1} added - ${successMessage}`, 'success');

                            log('Vertex addition completed', {
                                newVertex: newVertex.id + 1,
                                totalVertices: graph.vertices.length,
                                totalEdges: graph.edges.length,
                                totalFaces: graph.faces.length,
                                method: successMessage
                            });

                            showLoading(false);
                        }

                        // FIXED redrawGraph with deterministic layout
                        function redrawGraph(silent = false) {
                            if (graph.vertices.length <= 3) {
                                if (!silent) showAlert('Need more than 3 vertices to redraw', 'info');
                                return;
                            }

                            if (!silent) showLoading(true, 'Redrawing graph for better layout...');

                            setTimeout(() => {
                                try {
                                    log('Redrawing graph', { vertices: graph.vertices.length });

                                    graph.periphery = findConvexHull();
                                    log('Convex hull recalculated', { peripherySize: graph.periphery.length });

                                    const center = calculateGraphCenter();

                                    const maxRadius = Math.max(...graph.vertices.map(v => getVertexRadius(v.id)));
                                    let safeDistance = maxRadius * 3 + 50;

                                    let radiusMultiplier = 2.0;
                                    if (graph.vertices.length > 4) {
                                        radiusMultiplier = 3.0 + (graph.vertices.length - 4) * 0.15;
                                    }
                                    if (graph.vertices.length > 10) {
                                        radiusMultiplier = 6.0 + (graph.vertices.length - 10) * 0.08;
                                    }

                                    const minCircumference = safeDistance * graph.periphery.length * radiusMultiplier;
                                    const radius = Math.max(minCircumference / (2 * Math.PI), 400);

                                    log(`Using radius: ${radius}, multiplier: ${radiusMultiplier}`);

                                    const angleStep = (2 * Math.PI) / graph.periphery.length;

                                    // Position periphery vertices in a perfect circle
                                    for (let i = 0; i < graph.periphery.length; i++) {
                                        const id = graph.periphery[i];
                                        const angle = i * angleStep - Math.PI / 2;

                                        graph.vertices[id].x = center.x + radius * Math.cos(angle);
                                        graph.vertices[id].y = center.y + radius * Math.sin(angle);
                                    }

                                    // Use force-directed approach for internal vertices
                                    const internalVertices = graph.vertices.filter(v => !graph.periphery.includes(v.id));

                                    if (internalVertices.length > 0) {
                                        // Position internal vertices using spring forces
                                        for (let iteration = 0; iteration < 100; iteration++) {
                                            for (const vertex of internalVertices) {
                                                let forceX = 0;
                                                let forceY = 0;

                                                // Spring forces from connected vertices
                                                const neighbors = getNeighbors(vertex.id);
                                                for (const neighborId of neighbors) {
                                                    const neighbor = graph.vertices[neighborId];
                                                    const dx = neighbor.x - vertex.x;
                                                    const dy = neighbor.y - vertex.y;
                                                    const distance = Math.sqrt(dx * dx + dy * dy);

                                                    if (distance > 0) {
                                                        const targetDistance = CONFIG.MIN_EDGE_LENGTH * 1.5;
                                                        const force = (distance - targetDistance) * 0.01;
                                                        forceX += (dx / distance) * force;
                                                        forceY += (dy / distance) * force;
                                                    }
                                                }

                                                // Repulsion from all vertices
                                                for (const other of graph.vertices) {
                                                    if (other.id === vertex.id) continue;

                                                    const dx = vertex.x - other.x;
                                                    const dy = vertex.y - other.y;
                                                    const distance = Math.sqrt(dx * dx + dy * dy);

                                                    if (distance > 0 && distance < CONFIG.MIN_VERTEX_DISTANCE * 2) {
                                                        const force = CONFIG.MIN_VERTEX_DISTANCE * 2 / (distance * distance);
                                                        forceX += (dx / distance) * force;
                                                        forceY += (dy / distance) * force;
                                                    }
                                                }

                                                // Apply forces
                                                vertex.x += forceX;
                                                vertex.y += forceY;
                                            }
                                        }
                                    }

                                    // Check for overlaps and expand if necessary
                                    let overlaps = findAllOverlaps();
                                    let expansionAttempts = 0;

                                    while (overlaps.length > 0 && expansionAttempts < 5) {
                                        expansionAttempts++;
                                        expandGraphLayout(1.2);
                                        overlaps = findAllOverlaps();
                                    }

                                    updateStoredEdgeLengths();
                                    updateQuadTree();

                                    if (!silent) {
                                        centerGraph();
                                    } else {
                                        draw();
                                    }

                                    if (!silent) {
                                        showAlert('Graph layout improved successfully', 'success');
                                    }

                                    log('Graph redraw completed', {
                                        finalRadius: radius,
                                        overlapsRemaining: findAllOverlaps().length,
                                        expansionAttempts
                                    });

                                } catch (error) {
                                    log('Error redrawing graph', error);
                                    if (!silent) showAlert('Error redrawing graph', 'error');
                                } finally {
                                    if (!silent) showLoading(false);
                                }
                            }, 10);
                        }

                        // ===================================================================
                        // VALIDATION & ERROR CHECKING
                        // ===================================================================

                        function validateGraph() {
                            showLoading(true, 'Validating graph structure...');

                            setTimeout(() => {
                                try {
                                    const issues = [];

                                    for (const edge of graph.edges) {
                                        if (edge.v1 >= graph.vertices.length || edge.v2 >= graph.vertices.length ||
                                            edge.v1 < 0 || edge.v2 < 0) {
                                            issues.push(`Invalid edge: V${edge.v1 + 1}-V${edge.v2 + 1}`);
                                        }
                                    }

                                    for (const id of graph.periphery) {
                                        if (id >= graph.vertices.length || id < 0) {
                                            issues.push(`Invalid periphery vertex: V${id + 1}`);
                                        }
                                    }

                                    if (graph.periphery.length < 3) {
                                        issues.push('Periphery must have at least 3 vertices');
                                    }

                                    for (let i = 0; i < graph.periphery.length; i++) {
                                        const v1 = graph.periphery[i];
                                        const v2 = graph.periphery[(i + 1) % graph.periphery.length];

                                        if (!edgeExists(v1, v2)) {
                                            issues.push(`Missing periphery edge: V${v1 + 1}-V${v2 + 1}`);
                                        }
                                    }

                                    const crossings = findAllCrossings();
                                    if (crossings.length > 0) {
                                        issues.push(`Found ${crossings.length} edge crossings (non-planar!)`);
                                        for (const crossing of crossings.slice(0, 5)) {
                                            issues.push(`  Edge V${crossing.edge1.v1 + 1}-V${crossing.edge1.v2 + 1} crosses V${crossing.edge2.v1 + 1}-V${crossing.edge2.v2 + 1}`);
                                        }
                                    }

                                    const overlaps = findAllOverlaps();
                                    if (overlaps.length > 0) {
                                        issues.push(`Found ${overlaps.length} vertex overlaps`);
                                        for (const overlap of overlaps.slice(0, 3)) {
                                            issues.push(`  V${overlap.v1 + 1} overlaps with V${overlap.v2 + 1} (distance: ${overlap.distance.toFixed(1)})`);
                                        }
                                    }

                                    for (const vertex of graph.vertices) {
                                        const degree = getNeighbors(vertex.id).length;
                                        if (degree < 2 && graph.vertices.length > 3) {
                                            issues.push(`V${vertex.id + 1} has degree ${degree} (should be ≥ 2)`);
                                        }
                                    }

                                    let nonTriangularFaces = 0;
                                    for (const face of graph.faces) {
                                        if (face.length !== 3) {
                                            nonTriangularFaces++;
                                        }
                                    }
                                    if (nonTriangularFaces > 0) {
                                        issues.push(`Found ${nonTriangularFaces} non-triangular faces`);
                                    }

                                    const regularityScore = checkGraphRegularity();
                                    if (regularityScore < 0.7) {
                                        issues.push(`Graph regularity score: ${(regularityScore * 100).toFixed(1)}% (should be > 70%)`);
                                    }

                                    displayValidationResults(issues);

                                } catch (error) {
                                    log('Error during validation', error);
                                    showAlert('Validation error: ' + error.message, 'error');
                                } finally {
                                    showLoading(false);
                                }
                            }, 10);
                        }

                        function checkGraphRegularity() {
                            const edgeLengths = [];

                            for (const edge of graph.edges) {
                                const length = calculateDistance(graph.vertices[edge.v1], graph.vertices[edge.v2]);
                                edgeLengths.push(length);
                            }

                            if (edgeLengths.length === 0) return 1;

                            const avgLength = edgeLengths.reduce((a, b) => a + b, 0) / edgeLengths.length;
                            const variance = edgeLengths.reduce((sum, len) =>
                                sum + Math.pow(len - avgLength, 2), 0) / edgeLengths.length;
                            const stdDev = Math.sqrt(variance);

                            const cv = stdDev / avgLength;
                            return Math.max(0, 1 - cv);
                        }

                        function findAllCrossings() {
                            const crossings = [];

                            for (let i = 0; i < graph.edges.length; i++) {
                                const edge1 = graph.edges[i];
                                const v1 = graph.vertices[edge1.v1];
                                const v2 = graph.vertices[edge1.v2];

                                for (let j = i + 1; j < graph.edges.length; j++) {
                                    const edge2 = graph.edges[j];

                                    if (edge1.v1 === edge2.v1 || edge1.v1 === edge2.v2 ||
                                        edge1.v2 === edge2.v1 || edge1.v2 === edge2.v2) {
                                        continue;
                                    }

                                    const v3 = graph.vertices[edge2.v1];
                                    const v4 = graph.vertices[edge2.v2];

                                    if (doEdgesCross(v1.x, v1.y, v2.x, v2.y, v3.x, v3.y, v4.x, v4.y)) {
                                        crossings.push({ edge1, edge2 });
                                    }
                                }
                            }

                            return crossings;
                        }

                        function findAllOverlaps() {
                            const overlaps = [];

                            for (let i = 0; i < graph.vertices.length; i++) {
                                const v1 = graph.vertices[i];

                                for (let j = i + 1; j < graph.vertices.length; j++) {
                                    const v2 = graph.vertices[j];
                                    const distance = calculateDistance(v1, v2);

                                    const r1 = getVertexRadius(i);
                                    const r2 = getVertexRadius(j);
                                    const minAllowedDist = r1 + r2 + 15;

                                    if (distance < minAllowedDist) {
                                        overlaps.push({
                                            v1: i, v2: j,
                                            distance,
                                            overlap: minAllowedDist - distance
                                        });
                                    }
                                }
                            }

                            return overlaps;
                        }

                        function displayValidationResults(issues) {
                            const debugContent = document.getElementById('debugContent');
                            debugContent.innerHTML = '';

                            const result = document.createElement('div');
                            result.className = 'validation-result ' +
                                (issues.length === 0 ? 'validation-success' : 'validation-error');

                            if (issues.length === 0) {
                                result.innerHTML = '<strong>✓ Graph is valid!</strong>';
                                result.innerHTML += '<p>All planarity and structure checks passed.</p>';
                                result.innerHTML += `<p>Vertices: ${graph.vertices.length}, Edges: ${graph.edges.length}, Faces: ${graph.faces.length}</p>`;

                                const regularityScore = checkGraphRegularity();
                                result.innerHTML += `<p>Regularity score: ${(regularityScore * 100).toFixed(1)}%</p>`;

                                showAlert('Graph is valid and planar', 'success');
                            } else {
                                result.innerHTML = `<strong>⚠️ Found ${issues.length} issues:</strong>`;

                                const list = document.createElement('ul');
                                list.className = 'validation-list';

                                issues.forEach(issue => {
                                    const item = document.createElement('li');
                                    item.className = 'validation-item';
                                    item.textContent = issue;
                                    list.appendChild(item);
                                });

                                result.appendChild(list);
                                showAlert(`Found ${issues.length} issues`, 'error');
                            }

                            debugContent.appendChild(result);
                            debugPanel.classList.add('show');
                        }

                        // ===================================================================
                        // USER INTERACTION HANDLING
                        // ===================================================================

                        function handleVertexClick(vertexId) {
                            if (selection.mode === 'add') {
                                if (graph.periphery.includes(vertexId)) {
                                    if (selection.firstVertex === null) {
                                        selection.firstVertex = vertexId;
                                        selection.vertices = [vertexId];
                                        updateStatus('Select second periphery vertex (Vq)');
                                        updateSelectionInfo();
                                        draw();
                                        log('First vertex selected', { id: vertexId + 1 });
                                    } else if (selection.firstVertex !== vertexId) {
                                        try {
                                            const testVertices = getVerticesBetween(selection.firstVertex, vertexId);

                                            selection.secondVertex = vertexId;
                                            selection.vertices = [selection.firstVertex, vertexId];
                                            updateSelectionInfo();
                                            draw();

                                            log('Second vertex selected', {
                                                first: selection.firstVertex + 1,
                                                second: vertexId + 1,
                                                connectedCount: testVertices.length
                                            });

                                            setTimeout(() => {
                                                showLoading(true, 'Voronoi-based placement in progress...');
                                                try {
                                                    addNewVertex(selection.firstVertex, selection.secondVertex);
                                                } catch (error) {
                                                    log('Error adding vertex', error);
                                                    showLoading(false);
                                                }
                                            }, 100);

                                        } catch (error) {
                                            showAlert('Invalid selection: ' + error.message, 'error');
                                        }
                                    } else {
                                        showAlert('Please select a different vertex', 'error');
                                    }
                                } else {
                                    showAlert('Selected vertex must be on the periphery (shown in red)', 'error');
                                }
                            }
                        }

                        // ===================================================================
                        // VIEW OPERATIONS
                        // ===================================================================

                        function centerGraph() {
                            if (graph.vertices.length === 0) return;

                            let minX = Infinity, minY = Infinity;
                            let maxX = -Infinity, maxY = -Infinity;

                            for (const vertex of graph.vertices) {
                                if (vertex.id > view.maxVisibleVertex) continue;

                                const radius = getVertexRadius(vertex.id);
                                minX = Math.min(minX, vertex.x - radius);
                                minY = Math.min(minY, vertex.y - radius);
                                maxX = Math.max(maxX, vertex.x + radius);
                                maxY = Math.max(maxY, vertex.y + radius);
                            }

                            const graphWidth = maxX - minX + 80;
                            const graphHeight = maxY - minY + 80;

                            const scaleX = (stage.width() * 0.85) / graphWidth;
                            const scaleY = (stage.height() * 0.85) / graphHeight;
                            const newScale = Math.min(scaleX, scaleY, 2);

                            const centerX = (minX + maxX) / 2;
                            const centerY = (minY + maxY) / 2;

                            stage.scale({ x: newScale, y: newScale });
                            stage.position({
                                x: stage.width() / 2 - centerX * newScale,
                                y: stage.height() / 2 - centerY * newScale
                            });

                            stage.batchDraw();
                            log('Graph centered', { scale: newScale });
                        }

                        function zoom(factor) {
                            const oldScale = stage.scaleX();
                            const newScale = Math.max(0.1, Math.min(10, oldScale * factor));

                            const center = {
                                x: stage.width() / 2,
                                y: stage.height() / 2
                            };

                            stage.scale({ x: newScale, y: newScale });
                            stage.position({
                                x: center.x - (center.x - stage.x()) * factor,
                                y: center.y - (center.y - stage.y()) * factor
                            });

                            stage.batchDraw();
                        }

                        function handleGoTo() {
                            const index = parseInt(vertexIndex.value);

                            if (isNaN(index) || index < 1 || index > graph.vertices.length) {
                                showAlert('Please enter a valid vertex number', 'error');
                                return;
                            }

                            view.maxVisibleVertex = index - 1;
                            updateVisibilityText();
                            updateStatus(`Showing vertices V1 through V${index}`);
                            hideModal(goToModal);
                            draw();
                            log('Go to vertex', { maxVisible: index });
                        }

                        function updateVisibilityText() {
                            if (view.maxVisibleVertex === Number.MAX_SAFE_INTEGER) {
                                visibleUpTo.textContent = 'All';
                            } else {
                                visibleUpTo.textContent = `V${view.maxVisibleVertex + 1}`;
                            }
                        }

                        function toggleDisplay() {
                            view.showIndex = !view.showIndex;
                            displayMode.textContent = view.showIndex ? 'Index' : 'Color';
                            updateStatus(`Display mode: ${view.showIndex ? 'Index' : 'Color'}`);
                            draw();
                        }

                        function toggleCurvedEdges() {
                            view.showCurvedEdges = !view.showCurvedEdges;
                            curvedStatus.textContent = view.showCurvedEdges ? 'On' : 'Off';
                            updateStatus(`Curved edges: ${view.showCurvedEdges ? 'enabled' : 'disabled'}`);

                            // Update UI - toggle active class for the button
                            curveToggleBtn.classList.toggle('active', view.showCurvedEdges);

                            // Clear all existing edge shapes and recreate them
                            for (const key in konvaShapes.edges) {
                                konvaShapes.edges[key].destroy();
                            }
                            konvaShapes.edges = {};

                            // Redraw edges with the new settings
                            drawEdges();
                            stage.batchDraw();

                            log('Curved edges toggled', { enabled: view.showCurvedEdges });
                        }

                        function isEdgeInPeriphery(v1, v2) {
                            const p = graph.periphery;
                            for (let i = 0; i < p.length; i++) {
                                const curr = p[i];
                                const next = p[(i + 1) % p.length];
                                if ((curr === v1 && next === v2) || (curr === v2 && next === v1)) {
                                    return true;
                                }
                            }
                            return false;
                        }

                        // ===================================================================
                        // UI MANAGEMENT
                        // ===================================================================

                        function updateGraphInfo() {
                            vertexCounter.textContent = `Vertices: ${graph.vertices.length}`;
                            vertexCount.textContent = graph.vertices.length;
                            edgeCount.textContent = graph.edges.length;
                            faceCount.textContent = graph.faces.length;
                            peripheryCount.textContent = graph.periphery.length;

                            updateVisibilityText();
                            updatePeripheryList();
                            updateSelectionInfo();
                        }

                        function updatePeripheryList() {
                            peripheryList.innerHTML = '';

                            if (graph.periphery.length === 0) {
                                const item = document.createElement('div');
                                item.className = 'vertex-item';
                                item.textContent = 'No vertices yet';
                                peripheryList.appendChild(item);
                            } else {
                                for (const id of graph.periphery) {
                                    const item = document.createElement('div');
                                    item.className = 'vertex-item';

                                    const vertex = graph.vertices[id];
                                    const label = document.createElement('span');
                                    label.textContent = `V${id + 1}`;
                                    label.style.fontWeight = selection.vertices.includes(id) ? 'bold' : 'normal';
                                    label.style.color = selection.vertices.includes(id) ? colors.selectedColor : 'inherit';

                                    const coords = document.createElement('span');
                                    coords.textContent = `(${Math.round(vertex.x)}, ${Math.round(vertex.y)})`;
                                    coords.style.fontSize = '12px';
                                    coords.style.color = '#888';

                                    item.appendChild(label);
                                    item.appendChild(coords);
                                    peripheryList.appendChild(item);
                                }
                            }
                        }

                        function updateSelectionInfo() {
                            if (selection.vertices.length > 0) {
                                const labels = selection.vertices.map(id => `V${id + 1}`).join(', ');
                                selectionInfo.innerHTML = `<strong>${labels}</strong>`;

                                if (selection.mode === 'add' && selection.firstVertex !== null && selection.secondVertex === null) {
                                    selectionInfo.innerHTML += ' <em>(select second vertex)</em>';
                                }
                            } else {
                                selectionInfo.textContent = 'None';
                            }
                        }

                        function enableButtons() {
                            addBtn.disabled = false;
                            randomBtn.disabled = false;
                            goToBtn.disabled = false;
                            zoomInBtn.disabled = false;
                            zoomOutBtn.disabled = false;
                            centerBtn.disabled = false;
                            toggleBtn.disabled = false;
                            redrawBtn.disabled = false;
                            colorBtn.disabled = false;
                            curveToggleBtn.disabled = false;
                        }

                        // ===================================================================
                        // MODAL AND UI INTERACTIONS
                        // ===================================================================

                        function showModal(modal) {
                            modal.classList.add('show');

                            if (modal === goToModal) {
                                vertexIndex.max = graph.vertices.length;
                                vertexIndex.placeholder = `1-${graph.vertices.length}`;
                                vertexIndex.value = view.maxVisibleVertex === Number.MAX_SAFE_INTEGER ?
                                    graph.vertices.length : view.maxVisibleVertex + 1;
                                vertexIndex.focus();
                                vertexIndex.select();
                            }
                        }

                        function hideModal(modal) {
                            modal.classList.remove('show');
                        }

                        function togglePanel() {
                            sidePanel.classList.toggle('collapsed');
                            togglePanelBtn.classList.toggle('collapsed');
                            togglePanelBtn.textContent = sidePanel.classList.contains('collapsed') ? '▶' : '◀';
                        }

                        function toggleDebugPanel() {
                            debugPanel.classList.toggle('show');
                        }

                        // ===================================================================
                        // COLOR SYSTEM
                        // ===================================================================

                        function setupColorPalettes() {
                            const colorSettings = [
                                { id: 'swatch-color1', property: 'vertexColors', index: 0 },
                                { id: 'swatch-color2', property: 'vertexColors', index: 1 },
                                { id: 'swatch-color3', property: 'vertexColors', index: 2 },
                                { id: 'swatch-color4', property: 'vertexColors', index: 3 },
                                { id: 'swatch-borderColor', property: 'vertexBorderColor' },
                                { id: 'swatch-edgeColor', property: 'edgeColor' },
                                { id: 'swatch-peripheryColor', property: 'peripheryColor' }
                            ];

                            for (const config of colorSettings) {
                                const swatch = document.getElementById(config.id);
                                if (swatch) {
                                    const color = config.index !== undefined ?
                                        colors[config.property][config.index] :
                                        colors[config.property];

                                    swatch.style.backgroundColor = color;

                                    swatch.addEventListener('click', () => {
                                        const colorPicker = document.createElement('input');
                                        colorPicker.type = 'color';
                                        colorPicker.style.position = 'absolute';
                                        colorPicker.style.visibility = 'hidden';
                                        colorPicker.value = color;

                                        document.body.appendChild(colorPicker);

                                        colorPicker.click();
                                        colorPicker.addEventListener('input', (e) => {
                                            const newColor = e.target.value;

                                            if (config.index !== undefined) {
                                                colors[config.property][config.index] = newColor;
                                            } else {
                                                colors[config.property] = newColor;
                                            }

                                            swatch.style.backgroundColor = newColor;
                                            draw();
                                        });

                                        colorPicker.addEventListener('change', () => {
                                            document.body.removeChild(colorPicker);
                                        });
                                    });
                                }
                            }

                            log('Color swatch system initialized');
                        }

                        function saveColors() {
                            hideModal(colorModal);
                            draw();
                            showAlert('Color settings applied', 'success');
                            log('Colors saved', colors);
                        }

                        function resetColors() {
                            colors = JSON.parse(JSON.stringify(defaultColors));
                            setupColorPalettes();
                            draw();
                            showAlert('Colors reset to default', 'info');
                            log('Colors reset to default');
                        }

                        // ===================================================================
                        // IMPORT/EXPORT FUNCTIONALITY
                        // ===================================================================

                        function exportGraph() {
                            const data = {
                                version: '2.0',
                                timestamp: new Date().toISOString(),
                                graph: {
                                    vertices: graph.vertices,
                                    edges: graph.edges,
                                    periphery: graph.periphery,
                                    faces: graph.faces
                                },
                                colors: colors,
                                metadata: {
                                    totalVertices: graph.vertices.length,
                                    totalEdges: graph.edges.length,
                                    totalFaces: graph.faces.length
                                }
                            };

                            const json = JSON.stringify(data, null, 2);
                            const blob = new Blob([json], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);

                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `planar_graph_${Date.now()}.json`;
                            a.click();

                            URL.revokeObjectURL(url);
                            showAlert('Graph exported successfully', 'success');
                            log('Graph exported', data.metadata);
                        }

                        function importGraph() {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = '.json';

                            input.addEventListener('change', (e) => {
                                const file = e.target.files[0];
                                if (!file) return;

                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    try {
                                        const data = JSON.parse(event.target.result);

                                        if (!data.graph || !data.graph.vertices || !data.graph.edges) {
                                            throw new Error('Invalid graph file format');
                                        }

                                        graph.vertices = data.graph.vertices;
                                        graph.edges = data.graph.edges;
                                        graph.periphery = data.graph.periphery || [];
                                        graph.faces = data.graph.faces || [];
                                        graph.edgeLengths = new Map();

                                        if (data.colors) {
                                            colors = { ...colors, ...data.colors };
                                            setupColorPalettes();
                                        }

                                        updateAdjacencyMatrix();
                                        updateQuadTree();
                                        detectFaces();

                                        if (graph.periphery.length === 0 && graph.vertices.length >= 3) {
                                            graph.periphery = findConvexHull();
                                        }

                                        updateGraphInfo();
                                        enableButtons();
                                        centerGraph();

                                        showAlert('Graph imported successfully', 'success');
                                        log('Graph imported', {
                                            vertices: graph.vertices.length,
                                            edges: graph.edges.length,
                                            faces: graph.faces.length
                                        });

                                    } catch (error) {
                                        showAlert('Error importing graph: ' + error.message, 'error');
                                        log('Import error', error);
                                    }
                                };

                                reader.readAsText(file);
                            });

                            input.click();
                        }

                        // ===================================================================
                        // KEYBOARD SHORTCUTS
                        // ===================================================================

                        function handleKeyDown(e) {
                            if (document.activeElement.tagName === 'INPUT') return;

                            if (e.ctrlKey || e.metaKey) {
                                switch (e.key.toLowerCase()) {
                                    case 's':
                                        e.preventDefault();
                                        exportGraph();
                                        break;
                                    case 'o':
                                        e.preventDefault();
                                        importGraph();
                                        break;
                                }
                                return;
                            }

                            switch (e.key.toLowerCase()) {
                                case 's':
                                    if (!startBtn.disabled) startGraph();
                                    break;
                                case 'a':
                                    if (!addBtn.disabled) startAddVertex();
                                    break;
                                case 'r':
                                    if (!randomBtn.disabled) addRandomVertex();
                                    break;
                                case 'g':
                                    if (!goToBtn.disabled) showModal(goToModal);
                                    break;
                                case 'c':
                                    if (!centerBtn.disabled) centerGraph();
                                    break;
                                case 't':
                                    if (!toggleBtn.disabled) toggleDisplay();
                                    break;
                                case 'z':
                                    if (e.shiftKey) {
                                        if (!zoomOutBtn.disabled) zoom(1 / CONFIG.ZOOM_FACTOR);
                                    } else {
                                        if (!zoomInBtn.disabled) zoom(CONFIG.ZOOM_FACTOR);
                                    }
                                    break;
                                case '+':
                                case '=':
                                    if (!zoomInBtn.disabled) zoom(CONFIG.ZOOM_FACTOR);
                                    break;
                                case '-':
                                case '_':
                                    if (!zoomOutBtn.disabled) zoom(1 / CONFIG.ZOOM_FACTOR);
                                    break;
                                case 'd':
                                    toggleDebugPanel();
                                    break;
                                case 'escape':
                                    handleEscape();
                                    break;
                                case 'v':
                                    validateGraph();
                                    break;
                                case 'f':
                                    if (e.shiftKey || findAllOverlaps().length > 0 || findAllCrossings().length > 0) {
                                        fixGraph();
                                    }
                                    break;
                                case 'e':
                                    if (!curveToggleBtn.disabled) toggleCurvedEdges();
                                    break;
                            }
                        }

                        function handleEscape() {
                            if (debugPanel.classList.contains('show')) {
                                debugPanel.classList.remove('show');
                            } else if (colorModal.classList.contains('show')) {
                                hideModal(colorModal);
                            } else if (goToModal.classList.contains('show')) {
                                hideModal(goToModal);
                            } else if (selection.mode !== 'none') {
                                selection.mode = 'none';
                                selection.vertices = [];
                                selection.firstVertex = null;
                                selection.secondVertex = null;
                                updateStatus('Selection canceled');
                                updateSelectionInfo();
                                draw();
                            }
                        }

                        // ===================================================================
                        // INITIALIZATION AND EVENT SETUP
                        // ===================================================================

                        function init() {
                            log('Initializing Professional Planar Triangulated Graph Visualizer - FIXED VERSION');

                            initKonva();
                            setupEventListeners();
                            setupColorPalettes();

                            updateStatus('Ready to start. Press S or click Start to create initial triangle.');
                            updateVisibilityText();

                            curvedStatus.textContent = view.showCurvedEdges ? 'On' : 'Off';

                            draw();

                            setTimeout(() => {
                                showAlert('Fixed Version Ready! All major bugs resolved with Matter.js physics', 'success');
                            }, 500);

                            log('Fixed application initialized successfully with Matter.js physics engine');
                        }

                        function resizeCanvas() {
                            const container = document.getElementById('canvas-container');
                            if (stage) {
                                stage.width(container.clientWidth);
                                stage.height(container.clientHeight);
                                stage.batchDraw();
                            }
                        }

                        function setupEventListeners() {
                            startBtn.addEventListener('click', startGraph);
                            addBtn.addEventListener('click', startAddVertex);
                            randomBtn.addEventListener('click', addRandomVertex);
                            goToBtn.addEventListener('click', () => showModal(goToModal));
                            zoomInBtn.addEventListener('click', () => zoom(CONFIG.ZOOM_FACTOR));
                            zoomOutBtn.addEventListener('click', () => zoom(1 / CONFIG.ZOOM_FACTOR));
                            centerBtn.addEventListener('click', centerGraph);
                            toggleBtn.addEventListener('click', toggleDisplay);
                            redrawBtn.addEventListener('click', () => redrawGraph(false));
                            colorBtn.addEventListener('click', () => {
                                setupColorPalettes();
                                showModal(colorModal);
                            });
                            debugBtn.addEventListener('click', toggleDebugPanel);
                            validateBtn.addEventListener('click', validateGraph);
                            fixBtn.addEventListener('click', fixGraph);
                            exportBtn.addEventListener('click', exportGraph);
                            importBtn.addEventListener('click', importGraph);
                            curveToggleBtn.addEventListener('click', toggleCurvedEdges);

                            togglePanelBtn.addEventListener('click', togglePanel);
                            document.getElementById('closeDebugBtn').addEventListener('click', () => {
                                debugPanel.classList.remove('show');
                            });

                            confirmGoToBtn.addEventListener('click', handleGoTo);
                            cancelGoToBtn.addEventListener('click', () => hideModal(goToModal));

                            saveColorsBtn.addEventListener('click', saveColors);
                            resetColorsBtn.addEventListener('click', resetColors);

                            vertexIndex.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter') {
                                    handleGoTo();
                                }
                            });

                            goToModal.addEventListener('click', (e) => {
                                if (e.target === goToModal) hideModal(goToModal);
                            });

                            colorModal.addEventListener('click', (e) => {
                                if (e.target === colorModal) hideModal(colorModal);
                            });

                            window.addEventListener('resize', resizeCanvas);
                            document.addEventListener('keydown', handleKeyDown);
                        }

                        // ===================================================================
                        // ERROR HANDLING
                        // ===================================================================

                        window.addEventListener('error', (e) => {
                            log('Global error caught', {
                                message: e.message,
                                filename: e.filename,
                                line: e.lineno,
                                column: e.colno,
                                error: e.error
                            });
                            showAlert('An error occurred. Check console for details.', 'error');
                        });

                        // ===================================================================
                        // APPLICATION STARTUP
                        // ===================================================================

                        if (document.readyState === 'loading') {
                            document.addEventListener('DOMContentLoaded', init);
                        } else {
                            init();
                        }

                        // ===================================================================
                        // DEBUG TOOLS
                        // ===================================================================

                        window.graphDebug = {
                            graph,
                            view,
                            colors,
                            selection,
                            config: CONFIG,
                            stage,
                            layers: { faceLayer, edgeLayer, vertexLayer },
                            konvaShapes,
                            quadTree,
                            physicsEngine,
                            physicsRunner,

                            testPhysics: () => {
                                console.log('Physics Engine:', physicsEngine ? 'Active' : 'Inactive');
                                console.log('Physics Runner:', physicsRunner ? 'Running' : 'Stopped');
                                if (physicsEngine) {
                                    console.log('Bodies:', physicsEngine.world.bodies.length);
                                    console.log('Constraints:', physicsEngine.world.constraints.length);
                                }
                            },

                            getStats: () => {
                                const stats = {
                                    vertices: graph.vertices.length,
                                    edges: graph.edges.length,
                                    faces: graph.faces.length,
                                    periphery: graph.periphery.length,
                                    avgDegree: graph.edges.length * 2 / graph.vertices.length,
                                    isPlanar: findAllCrossings().length === 0,
                                    hasOverlaps: findAllOverlaps().length > 0,
                                    regularityScore: checkGraphRegularity(),
                                    memoryUsage: JSON.stringify(graph).length / 1024 + ' KB'
                                };

                                console.table(stats);
                                return stats;
                            },

                            addRandomVertices: (count) => {
                                let added = 0;
                                const interval = setInterval(() => {
                                    if (added >= count || graph.vertices.length >= CONFIG.MAX_VERTICES) {
                                        clearInterval(interval);
                                        showAlert(`Added ${added} vertices`, 'success');
                                        return;
                                    }

                                    if (graph.periphery.length >= 2) {
                                        addRandomVertex();
                                        added++;
                                    }
                                }, 1000);
                            }
                        };

                        log('🚀 FIXED Professional Planar Triangulated Graph Visualizer');
                        log('✅ Matter.js physics engine integrated');
                        log('✅ Curved edges fixed with Konva.Path');
                        log('✅ Angular resolution improved to PI/4');
                        log('✅ Position update system optimized');
                        log('✅ QuadTree spatial indexing implemented');
                        log('✅ All critical bugs resolved');

                    })();
                </script>